---
import SquareButton from "./SquareButton.astro";
import CardFull from "./CardFull.astro";
import Button from "./Button.astro";
import SpaceButton from "./SpaceButton.astro";
import TrixEditor from "./TrixEditor.astro";
import Toast from "./Toast-v2.astro";
// Sample data imports removed - using real database data only
import { getThreadGradientCSS } from "@/utils/colors";
import { notes } from "@/actions/notes";
import { getAllThreadsWithCounts } from "@/utils/dashboard-data";

export interface Props {
  onClose?: () => void;
}

const { onClose } = Astro.props;

// Get user ID from Clerk authentication
const { userId } = Astro.locals.auth();
console.log("NewNotePanel: Using authenticated user ID:", userId);

if (!userId) {
  return Astro.redirect('/sign-in');
}

// Note: Thread options will be loaded dynamically via API in x-init
---

<form 
  action="/api/notes/create"
  method="POST"
  class="new-note-panel h-full flex flex-col justify-between"
  x-data="{ 
    title: localStorage.getItem('newNoteTitle') || '',
    content: localStorage.getItem('newNoteContent') || '',
    selectedThread: localStorage.getItem('newNoteThread') || 'Unorganized',
    isOpen: false,
    isSubmitting: false,
    nextNoteId: '#New',
    threadOptions: [
      {
        id: 'thread_unorganized',
        title: 'Unorganized',
        color: null,
        noteCount: 0,
        backgroundGradient: 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)'
      }
    ],
    getThreadGradientCSS(color) {
      if (!color) return 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)';
      const colorMap = {
        'blessed-blue': 'var(--color-blessed-blue)',
        'graceful-gold': 'var(--color-graceful-gold)',
        'caring-coral': 'var(--color-caring-coral)',
        'mindful-mint': 'var(--color-mindful-mint)',
        'peaceful-pink': 'var(--color-peaceful-pink)',
        'pleasant-peach': 'var(--color-pleasant-peach)',
        'lovely-lavender': 'var(--color-lovely-lavender)'
      };
      const baseColor = colorMap[color] || 'var(--color-blessed-blue)';
      return `linear-gradient(180deg, ${baseColor} 0%, ${baseColor} 100%)`;
    },
    getSelectedThread() {
      return this.threadOptions.find(thread => thread.title === this.selectedThread) || this.threadOptions[0];
    },
    submitForm() {
      this.isSubmitting = true;
    },
    closePanel() {
      localStorage.removeItem('newNoteTitle');
      localStorage.removeItem('newNoteThread');
      localStorage.removeItem('newNoteContent');
      this.title = '';
      this.content = '';
      this.selectedThread = 'Unorganized';
      this.isSubmitting = false;
      window.dispatchEvent(new CustomEvent('closeNewNotePanel'));
    },
    async loadThreads() {
      try {
        console.log('Loading threads from API...');
        const response = await fetch('/api/threads/list');
        console.log('API response status:', response.status);
        
        if (response.ok) {
          const threads = await response.json();
          console.log('Loaded threads:', threads);
          
          this.threadOptions = threads.map(thread => ({
            id: thread.id,
            title: thread.title,
            color: thread.color,
            noteCount: thread.noteCount,
            backgroundGradient: thread.backgroundGradient || `linear-gradient(180deg, var(--color-${thread.color || 'blessed-blue'}) 0%, var(--color-${thread.color || 'blessed-blue'}) 100%)`
          }));
          
          // Ensure 'Unorganized' thread exists
          const hasUnorganizedThread = this.threadOptions.some(thread => thread.title === 'Unorganized');
          if (!hasUnorganizedThread) {
            this.threadOptions.unshift({
              id: 'thread_unorganized',
              title: 'Unorganized',
              color: null,
              noteCount: 0,
              backgroundGradient: 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)'
            });
          }
          
          console.log('Final threadOptions:', this.threadOptions);
        } else {
          console.error('API request failed:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('Error loading threads:', error);
      }
    },
    async refreshThreads() {
      await this.loadThreads();
    },
    async loadNextNoteId() {
      try {
        console.log('Loading next note ID from API...');
        const response = await fetch('/api/notes/next-id');
        console.log('Next note ID API response status:', response.status);
        
        if (response.ok) {
          const data = await response.json();
          console.log('Loaded next note ID:', data);
          this.nextNoteId = `#${data.formattedId}`;
        } else {
          console.error('Next note ID API request failed:', response.status, response.statusText);
          this.nextNoteId = '#New';
        }
      } catch (error) {
        console.error('Error loading next note ID:', error);
        this.nextNoteId = '#New';
      }
    }
  }"
  x-init="
    // Load threads from API
    loadThreads();
    
    // Load next note ID from API
    loadNextNoteId();
    
    // Save form data to localStorage when it changes
    $watch('title', value => localStorage.setItem('newNoteTitle', value));
    $watch('content', value => localStorage.setItem('newNoteContent', value));
    $watch('selectedThread', value => localStorage.setItem('newNoteThread', value));
    
    // Clear form when panel is opened
    window.addEventListener('openNewNotePanel', () => {
      title = '';
      content = '';
      selectedThread = 'Unorganized';
      isSubmitting = false;
      localStorage.removeItem('newNoteTitle');
      localStorage.removeItem('newNoteThread');
      localStorage.removeItem('newNoteContent');
      // Refresh the next note ID when panel opens
      loadNextNoteId();
    });
    
    // Listen for new thread creation to refresh the dropdown
    window.addEventListener('threadCreated', () => {
      refreshThreads();
    });
  "

>
  <!-- Hidden form fields -->

  <input type="hidden" name="threadId" x-bind:value="getSelectedThread().id" />
  <input type="hidden" name="content" x-model="content" />
  <input type="hidden" name="title" x-model="title" />

  <!-- Content area that expands to fill available space -->
  <div class="flex-1 flex flex-col min-h-0">
    <!-- Thread Selection using SpaceButton dropdown variant -->
    <div class="mb-3.5">
      <div class="relative">
        <div 
          @click.prevent.stop="isOpen = !isOpen"
          class="w-full cursor-pointer"
        >
          <SpaceButton 
            text=""
            state="DropdownTrigger"
            count={0}
            className="w-full"
            backgroundGradient="linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)"
            isActive={false}
            x-bind:style="`background-image: ${getSelectedThread().backgroundGradient};`"
          >
            <span slot="text" x-text="selectedThread" class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap">Unorganized</span>
            <span slot="count" x-text="getSelectedThread().noteCount" class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]">0</span>
          </SpaceButton>
        </div>
        
        <!-- Dropdown content -->
        <div 
          x-show="isOpen"
          x-transition:enter="transition ease-out duration-200"
          x-transition:enter-start="opacity-0 transform scale-95"
          x-transition:enter-end="opacity-100 transform scale-100"
          x-transition:leave="transition ease-in duration-150"
          x-transition:leave-start="opacity-100 transform scale-100"
          x-transition:leave-end="opacity-0 transform scale-95"
          class="absolute top-full left-0 right-0 mt-2 z-10"
          style="min-width: 223px;"
          @click.outside="isOpen = false"
        >
          <!-- Thread options using SpaceButton styling -->
          <div>
            <template x-for="thread in threadOptions" :key="thread.id">
              <button 
                type="button"
                @click="selectedThread = thread.title; isOpen = false"
                class="space-button relative rounded-xl h-[64px] cursor-pointer transition-[scale,shadow] duration-300 pl-4 pr-0 w-full"
                x-bind:style="`background-image: ${thread.backgroundGradient};`"
              >
                <div class="flex items-center justify-between relative w-full h-full pl-2 pr-0 transition-transform duration-125">
                  <span class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap" x-text="thread.title"></span>
                  <div class="p-[20px]">
                    <div class="bg-[rgba(120,118,111,0.1)] flex items-center justify-center rounded-3xl w-6 h-6">
                      <span class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]" x-text="thread.noteCount">
                      </span>
                    </div>
                  </div>
                </div>
              </button>
            </template>
            

          </div>
        </div>
      </div>
    </div>

    <!-- Note Content using CardFull-style form -->
    <div class="flex-1 flex flex-col min-h-0 mb-3.5">
      <div class="bg-white box-border flex flex-col min-h-0 flex-1 items-start justify-between overflow-clip pb-3 pt-6 px-3 relative rounded-[24px] shadow-[0px_3px_20px_0px_rgba(120,118,111,0.1)]">
      <!-- Header with title input and bookmark icon (like CardFull) -->
      <div class="flex gap-3 items-center justify-center px-3 py-0 relative shrink-0 w-full">
        <div class="basis-0 font-sans font-semibold grow leading-[0] min-h-px min-w-px not-italic relative shrink-0 text-[var(--color-deep-grey)] text-[24px]">
          <input 
            type="text"
            x-model="title"
            placeholder="Note title"
            class="w-full bg-transparent border-none text-[24px] font-semibold text-[var(--color-deep-grey)] focus:outline-none placeholder-[var(--color-pebble-grey)]"
          />
        </div>
        <div class="relative shrink-0 size-5">
          <svg class="block max-w-none size-full text-[var(--color-deep-grey)] " fill="currentColor" viewBox="0 0 24 24">
            <path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z"/>
          </svg>
        </div>
      </div>
      
      <!-- Content area with TrixEditor (like CardFull) -->
      <div class="flex-1 flex items-start justify-between px-3 py-0 relative w-full min-h-0">
        <div class="flex flex-col font-sans font-normal w-full h-full">
          <textarea 
            x-model="content"
            placeholder="Start writing your note..."
            class="w-full h-full min-h-[200px] p-3 border-none bg-transparent resize-none focus:outline-none text-[var(--color-deep-grey)] font-sans font-normal"
            style="font-family: inherit;"
          ></textarea>
        </div>
      </div>

      <!-- Date and Note ID (like CardFull) -->
      <div class="flex font-sans font-normal items-center justify-between leading-[0] not-italic px-3 py-0 relative shrink-0 text-[var(--color-stone-grey)] text-[12px] text-nowrap w-full">
        <div class="relative shrink-0">
          <p class="leading-[normal] text-nowrap whitespace-pre">Today</p>
        </div>
        <div class="relative shrink-0">
          <p class="leading-[normal] text-nowrap whitespace-pre" id="new-note-id" x-text="nextNoteId">#New</p>
        </div>
      </div>
      
    </div>
  </div>
  </div>

  <!-- Bottom buttons -->
  <div class="flex items-center justify-between gap-3">
    <div id="close-new-note-btn" @click.prevent="closePanel()">
      <SquareButton variant="Close" type="button" />
    </div>
    <Button 
      state="Default"
      type="button"
      id="create-note-btn"
      class="flex-1"
      x-bind:disabled="isSubmitting"
    >
      <span x-show="!isSubmitting">Create Note</span>
      <span x-show="isSubmitting">Creating...</span>
    </Button>
  </div>
</form>

<!-- Toast component -->
<Toast />

<script>
  // Handle URL thread detection after component loads
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const form = document.querySelector('.new-note-panel') as any;
      if (form && form.__x && form.__x.$data) {
        const alpineData = form.__x.$data;
        try {
          const urlParams = new URLSearchParams(window.location.search);
          const activeThreadElement = document.querySelector('[data-active-thread]') as HTMLElement;
          const activeThread = urlParams.get('thread') || activeThreadElement?.dataset.activeThread;
          if (activeThread) {
            alpineData.selectedThread = activeThread;
            localStorage.setItem('newNoteThread', activeThread);
          }
        } catch (e) {
          console.log('Could not get active thread from URL');
        }
      }
    }, 100);
  });
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Handle create note button click
    const createBtn = document.getElementById('create-note-btn');
    if (createBtn) {
      createBtn.addEventListener('click', async (e) => {
        console.log('Button clicked, validating form');
        e.preventDefault(); // Prevent default form submission
        const form = document.querySelector('form');
        if (!form) return;
        
        let alpineData;
        try {
          alpineData = (window as any).Alpine?.$data(form);
        } catch (e) {
          console.log('Alpine data not available:', e);
        }
        
        // Get content from Alpine.js data (textarea with x-model)
        let content = '';
        if (alpineData?.content) {
          content = alpineData.content;
        }
        
        if (!content.trim()) {
          console.log('No content, preventing submission');
          alert('Please add some content to your note');
          return;
        }
        
        // Set submitting state
        if (alpineData) {
          alpineData.isSubmitting = true;
        }
        
        console.log('Form validation passed, submitting via API');
        
        try {
          const formData = new FormData(form);
          console.log('Submitting to:', form.action);
          
          const response = await fetch(form.action, {
            method: 'POST',
            body: formData,
            credentials: 'include'
          });
          
          console.log('Response status:', response.status);
          
          if (response.ok) {
            const result = await response.json();
            console.log('Success result:', result);
            
            window.dispatchEvent(new CustomEvent('toast', {
              detail: {
                message: result.success || 'Note created successfully!',
                type: 'success'
              }
            }));
            
            // Navigate to the newly created note
            if (result.note && result.note.id) {
              // Small delay to show the toast before navigation
              setTimeout(() => {
                window.location.href = `/${result.note.id}`;
              }, 1000);
            }
            
            // Reset form
            if (alpineData) {
              alpineData.title = '';
              alpineData.content = '';
              alpineData.selectedThread = 'Unorganized';
              alpineData.isSubmitting = false;
              // Refresh the next note ID after successful creation
              if (alpineData.loadNextNoteId) {
                alpineData.loadNextNoteId();
              }
              if (alpineData.closePanel) {
                alpineData.closePanel();
              }
            }
            
            // Clear localStorage
            localStorage.removeItem('newNoteTitle');
            localStorage.removeItem('newNoteThread');
            localStorage.removeItem('newNoteContent');
            
          } else {
            const error = await response.json();
            console.error('Error response:', error);
            
            window.dispatchEvent(new CustomEvent('toast', {
              detail: {
                message: error.error || 'Error creating note',
                type: 'error'
              }
            }));
            
            if (alpineData) {
              alpineData.isSubmitting = false;
            }
          }
        } catch (error) {
          console.error('Fetch error:', error);
          window.dispatchEvent(new CustomEvent('toast', {
            detail: {
              message: 'Error creating note. Please try again.',
              type: 'error'
            }
          }));
          
          if (alpineData) {
            alpineData.isSubmitting = false;
          }
        }
      });
    }
  });
</script>

<style>
  /* SpaceButton styling for dropdown items */
  .space-button {
    will-change: transform;
    transition: box-shadow 0.125s ease-in-out;
  }

  .space-button[style*="background-image"] {
    box-shadow: 0px -3px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:not([data-outer-shadow]):active {
    filter: brightness(0.97);
    box-shadow: 
      0px -1px 0px 0px rgba(120, 118, 111, 0.2) inset,
      0px 1px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:active > div {
    translate: 0 0;
    transform: scale(0.98);
  }

  /* Custom TrixEditor styling for NewNotePanel */
  .new-note-panel trix-editor {
    border: none !important;
    border-radius: 0 !important;
    padding: 0 !important;
    background: white !important;
    box-shadow: none !important;
  }

  .new-note-panel #trix-editor {
    border: none !important;
    border-radius: 0 !important;
    padding: 0 !important;
    background: white !important;
  }

  /* HTMX loading states */
  .htmx-request #create-note-btn {
    opacity: 0.7;
    pointer-events: none;
  }

  .htmx-request #create-note-btn span:first-child {
    display: none;
  }

  .htmx-request #create-note-btn span:last-child {
    display: block;
  }
</style>
