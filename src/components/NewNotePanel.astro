---
import SquareButton from "./SquareButton.astro";
import CardFull from "./CardFull.astro";
import Button from "./Button.astro";
import SpaceButton from "./SpaceButton.astro";
import QuillEditor from "./QuillEditor.astro";
import Toast from "./Toast-v2.astro";
// Sample data imports removed - using real database data only
import { getThreadGradientCSS } from "@/utils/colors";
import { notes } from "@/actions/notes";
import { getAllThreadsWithCounts } from "@/utils/dashboard-data";

export interface Props {
  onClose?: () => void;
  currentThread?: any;
}

const { onClose, currentThread } = Astro.props;

// Get user ID from Clerk authentication
const { userId } = Astro.locals.auth();
// Debug logs removed for cleaner console output

if (!userId) {
  return Astro.redirect('/sign-in');
}

// Note: Thread options will be loaded dynamically via API in x-init
---

<form 
  action="/api/notes/create"
  method="POST"
  class="new-note-panel h-full flex flex-col justify-between"
  data-current-thread-title={currentThread?.title || ''}
  data-current-thread-id={currentThread?.id || ''}
  x-data="{ 
    title: localStorage.getItem('newNoteTitle') || '',
    content: localStorage.getItem('newNoteContent') || '',
    selectedThread: localStorage.getItem('newNoteThread') || 'Unorganized',
    isOpen: false,
    isSubmitting: false,
    nextNoteId: '#New',
    threadOptions: [
      {
        id: 'thread_unorganized',
        title: 'Unorganized',
        color: null,
        noteCount: 0,
        backgroundGradient: 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)'
      }
    ],
    getSelectedThread() {
      return this.threadOptions.find(thread => thread.title === this.selectedThread) || this.threadOptions[0];
    },
    submitForm() {
      this.isSubmitting = true;
    },
    closePanel() {
      localStorage.removeItem('newNoteTitle');
      localStorage.removeItem('newNoteThread');
      localStorage.removeItem('newNoteContent');
      this.title = '';
      this.content = '';
      this.selectedThread = 'Unorganized';
      this.isSubmitting = false;
      window.dispatchEvent(new CustomEvent('closeNewNotePanel'));
    },
    async loadThreads() {
      try {
        const response = await fetch('/api/threads/list', {
          credentials: 'include'
        });
        
        if (response.ok) {
          const threads = await response.json();
          
          this.threadOptions = threads.map(thread => ({
            id: thread.id,
            title: thread.title,
            color: thread.color,
            noteCount: thread.noteCount,
            backgroundGradient: thread.backgroundGradient
          }));
          
          // Ensure 'Unorganized' thread exists
          const hasUnorganizedThread = this.threadOptions.some(thread => thread.title === 'Unorganized');
          if (!hasUnorganizedThread) {
            this.threadOptions.unshift({
              id: 'thread_unorganized',
              title: 'Unorganized',
              color: null,
              noteCount: 0,
              backgroundGradient: 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)'
            });
          }
        } else {
          console.error('API request failed:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('Error loading threads:', error);
      }
    },
    async refreshThreads() {
      await this.loadThreads();
    },
    async loadNextNoteId() {
      try {
        const response = await fetch('/api/notes/next-id', {
          credentials: 'include'
        });
        
        if (response.ok) {
          const data = await response.json();
          this.nextNoteId = `#${data.formattedId}`;
        } else {
          console.error('Next note ID API request failed:', response.status, response.statusText);
          this.nextNoteId = '#New';
        }
      } catch (error) {
        console.error('Error loading next note ID:', error);
        this.nextNoteId = '#New';
      }
    }
  }"
  x-init="
    // Load next note ID from API
    loadNextNoteId();
    
    // Load threads from API
    loadThreads();
    
    // Save form data to localStorage when it changes
    $watch('title', value => localStorage.setItem('newNoteTitle', value));
    $watch('content', value => localStorage.setItem('newNoteContent', value));
    $watch('selectedThread', value => localStorage.setItem('newNoteThread', value));
    
    // Clear form when panel is opened
    window.addEventListener('openNewNotePanel', () => {
      title = '';
      content = '';
      isSubmitting = false;
      localStorage.removeItem('newNoteTitle');
      localStorage.removeItem('newNoteContent');
      
      // Refresh the next note ID when panel opens
      loadNextNoteId();
      
      // Trigger pre-selection logic when panel opens
      setTimeout(() => {
        // Call the global updateThreadSelection function directly
        if (typeof window.updateThreadSelection === 'function') {
          window.updateThreadSelection();
        }
      }, 100);
    });
    
    // Listen for new thread creation to refresh the dropdown
    window.addEventListener('threadCreated', (event) => {
      refreshThreads().then(() => {
        // If a new thread was created, pre-select it
        if (event.detail && event.detail.thread && event.detail.thread.title) {
          selectedThread = event.detail.thread.title;
          localStorage.setItem('newNoteThread', event.detail.thread.title);
        }
      });
    });
    
  "

>
  <!-- Hidden form fields -->

  <input type="hidden" name="threadId" x-bind:value="getSelectedThread().id" />
  <input type="hidden" name="title" x-model="title" />

  <!-- Content area that expands to fill available space -->
  <div class="flex-1 flex flex-col min-h-0">
    <!-- Thread Selection using SpaceButton dropdown variant -->
    <div class="mb-3.5">
      <div class="relative">
        <div 
          @click.prevent.stop="isOpen = !isOpen"
          class="w-full cursor-pointer"
        >
          <SpaceButton 
            text=""
            state="DropdownTrigger"
            count={0}
            className="w-full"
            backgroundGradient="linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)"
            isActive={false}
            x-bind:style="`background-image: ${getSelectedThread().backgroundGradient};`"
          >
            <span slot="text" x-text="selectedThread" class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap">Unorganized</span>
            <span slot="count" x-text="getSelectedThread().noteCount" class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]">0</span>
          </SpaceButton>
        </div>
        
        <!-- Dropdown content -->
        <div 
          x-show="isOpen"
          x-transition:enter="transition ease-out duration-200"
          x-transition:enter-start="opacity-0 transform scale-95"
          x-transition:enter-end="opacity-100 transform scale-100"
          x-transition:leave="transition ease-in duration-150"
          x-transition:leave-start="opacity-100 transform scale-100"
          x-transition:leave-end="opacity-0 transform scale-95"
          class="absolute top-full left-0 right-0 mt-2 z-10"
          style="min-width: 223px;"
          @click.outside="isOpen = false"
        >
          <!-- Thread options using SpaceButton styling -->
          <div>
            <template x-for="thread in threadOptions" :key="thread.id">
              <button 
                type="button"
                @click="selectedThread = thread.title; isOpen = false"
                class="space-button relative rounded-xl h-[64px] cursor-pointer transition-[scale,shadow] duration-300 pl-4 pr-0 w-full"
                x-bind:style="`background-image: ${thread.backgroundGradient};`"
              >
                <div class="flex items-center justify-between relative w-full h-full pl-2 pr-0 transition-transform duration-125">
                  <span class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap" x-text="thread.title"></span>
                  <div class="p-[20px]">
                    <div class="bg-[rgba(120,118,111,0.1)] flex items-center justify-center rounded-3xl w-6 h-6">
                      <span class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]" x-text="thread.noteCount">
                      </span>
                    </div>
                  </div>
                </div>
              </button>
            </template>
            

          </div>
        </div>
      </div>
    </div>

    <!-- Note Content using CardFull-style form -->
    <div class="flex-1 flex flex-col min-h-0 mb-3.5">
      <div class="bg-white box-border flex flex-col min-h-0 flex-1 items-start justify-between overflow-clip pb-3 pt-6 px-3 relative rounded-[24px] shadow-[0px_3px_20px_0px_rgba(120,118,111,0.1)]">
      <!-- Header with title input and bookmark icon (like CardFull) -->
      <div class="flex gap-3 items-center justify-center px-3 py-0 relative shrink-0 w-full">
        <div class="basis-0 font-sans font-semibold grow leading-[0] min-h-px min-w-px not-italic relative shrink-0 text-[var(--color-deep-grey)] text-[24px]">
          <input 
            type="text"
            x-model="title"
            placeholder="Note title"
            class="w-full bg-transparent border-none text-[24px] font-semibold text-[var(--color-deep-grey)] focus:outline-none placeholder-[var(--color-pebble-grey)]"
          />
        </div>
        <div class="relative shrink-0 size-5">
          <svg class="block max-w-none size-full text-[var(--color-deep-grey)] " fill="currentColor" viewBox="0 0 24 24">
            <path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z"/>
          </svg>
        </div>
      </div>
      
      <!-- Content area with TrixEditor (like CardFull) -->
      <div class="flex-1 flex items-start justify-between px-3 py-0 relative w-full min-h-0">
        <div class="flex flex-col font-sans font-normal w-full h-full">
          <QuillEditor 
            content=""
            id="new-note-content"
            name="content"
            placeholder="Start writing your note..."
          />
        </div>
      </div>

      <!-- Date and Note ID (like CardFull) -->
      <div class="flex font-sans font-normal items-center justify-between leading-[0] not-italic px-3 py-0 relative shrink-0 text-[var(--color-stone-grey)] text-[12px] text-nowrap w-full">
        <div class="relative shrink-0">
          <p class="leading-[normal] text-nowrap whitespace-pre">Today</p>
        </div>
        <div class="relative shrink-0">
          <p class="leading-[normal] text-nowrap whitespace-pre" id="new-note-id" x-text="nextNoteId">#New</p>
        </div>
      </div>
      
    </div>
  </div>
  </div>

  <!-- Bottom buttons -->
  <div class="flex items-center justify-between gap-3">
    <div id="close-new-note-btn" @click.prevent="closePanel()">
      <SquareButton variant="Close" type="button" />
    </div>
    <Button 
      state="Default"
      type="button"
      id="create-note-btn"
      class="flex-1"
      x-bind:disabled="isSubmitting"
    >
      <span x-show="!isSubmitting">Create Note</span>
      <span x-show="isSubmitting">Creating...</span>
    </Button>
  </div>
</form>

<!-- Toast component -->
<Toast />

<script>
  // Following Astro MCP best practices for View Transitions lifecycle events
  // Using astro:after-swap for immediate DOM access after content swap
  document.addEventListener('astro:after-swap', () => {
    updateThreadSelection();
  });
  
  // Also listen to astro:page-load as backup (runs after scripts are executed)
  document.addEventListener('astro:page-load', () => {
    // Use a small delay to ensure Alpine.js is fully initialized
    setTimeout(updateThreadSelection, 100);
  });
  
  // Also listen to popstate for browser back/forward navigation
  window.addEventListener('popstate', () => {
    setTimeout(updateThreadSelection, 100);
  });
  
  
  // Centralized function to update thread selection following Alpine.js best practices
  function updateThreadSelection(attempt = 1) {
    const currentPath = window.location.pathname;
    
    // Find the NewNotePanel form element
    const form = document.querySelector('.new-note-panel') as any;
    if (!form) {
      if (attempt < 5) {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
      return;
    }
    
    // Get Alpine.js data using proper Alpine.js API
    let alpineData;
    try {
      // Use Alpine's $data method for proper data access
      alpineData = (window as any).Alpine?.$data(form);
    } catch (e) {
      if (attempt < 5) {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
      return;
    }
    
    if (!alpineData) {
      if (attempt < 5) {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
      return;
    }
    
    let selectedThread = null;
    let updated = false;
    
    if (currentPath.includes('/thread_')) {
      // For thread pages, get title from CardStack header (p element)
      const threadTitleElement = document.querySelector('div[style*="background-color"] p');
      if (threadTitleElement && threadTitleElement.textContent) {
        const threadTitle = threadTitleElement.textContent.trim();
        if (threadTitle && threadTitle !== 'Dashboard') {
          selectedThread = threadTitle;
          updated = true;
        }
      }
    } else if (currentPath.includes('/note_')) {
      // For note pages, use data attribute from currentThread prop
      const currentThreadTitle = form.dataset.currentThreadTitle;
      if (currentThreadTitle && currentThreadTitle.trim()) {
        selectedThread = currentThreadTitle;
        updated = true;
      }
    } else if (currentPath === '/dashboard' || currentPath === '/') {
      // If on dashboard, default to Unorganized
      selectedThread = 'Unorganized';
      updated = true;
    }
    
    // Update Alpine.js data if we found a thread
    if (selectedThread && updated) {
      alpineData.selectedThread = selectedThread;
      localStorage.setItem('newNoteThread', selectedThread);
    } else if (!updated && attempt < 5) {
      setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
    }
  }
  
  // Make the function available globally
  (window as any).updateThreadSelection = updateThreadSelection;
  
  // MutationObserver for dynamic attribute changes (following Alpine.js best practices)
  let observer: MutationObserver | null = null;
  
  function setupMutationObserver() {
    if (observer) {
      observer.disconnect();
    }
    
    const form = document.querySelector('.new-note-panel');
    if (!form) return;
    
    observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-current-thread-title') {
          const currentPath = window.location.pathname;
          const currentThreadTitle = (mutation.target as any).dataset.currentThreadTitle;
          
          if (currentPath.includes('/note_') && currentThreadTitle) {
            // Get Alpine.js data using proper API
            let alpineData;
            try {
              alpineData = (window as any).Alpine?.$data(mutation.target);
            } catch (e) {
              return;
            }
            
            if (alpineData) {
              alpineData.selectedThread = currentThreadTitle;
              localStorage.setItem('newNoteThread', currentThreadTitle);
            }
          }
        }
      });
    });
    
    // Start observing the form element for attribute changes
    observer.observe(form, {
      attributes: true,
      attributeFilter: ['data-current-thread-title']
    });
  }
  
  // Setup mutation observer following Astro best practices
  document.addEventListener('DOMContentLoaded', setupMutationObserver);
  document.addEventListener('astro:after-swap', () => {
    setTimeout(setupMutationObserver, 50);
  });
  
  // Setup create note button handler
  function setupCreateNoteButton() {
    const createBtn = document.getElementById('create-note-btn');
    if (createBtn) {
      createBtn.addEventListener('click', async (e) => {
        e.preventDefault(); // Prevent default form submission
        const form = document.querySelector('form');
        if (!form) return;
        
        let alpineData;
        try {
          alpineData = (window as any).Alpine?.$data(form);
        } catch (e) {
          // Alpine data not available
        }
        
        // Get content from StaticQuill Editor
        let content = '';
        const quillContainer = document.querySelector('#static-quill-container-new-note-content') as any;
        const hiddenInput = document.querySelector('input[name="content"]') as HTMLInputElement;
        
        // Try to get content from hidden input first (most reliable)
        if (hiddenInput && hiddenInput.value) {
          content = hiddenInput.value;
        }
        
        // Fallback to Quill Editor
        if (!content && quillContainer && quillContainer.__quill) {
          try {
            content = quillContainer.__quill.root.innerHTML;
          } catch (error) {
            console.error('Error getting content from Quill Editor:', error);
          }
        }
        
        // Fallback to Alpine data
        if (!content && alpineData?.content) {
          content = alpineData.content;
        }
        
        // Get threadId from Alpine data to ensure it's correct
        let threadId = '';
        if (alpineData && alpineData.getSelectedThread) {
          const selectedThread = alpineData.getSelectedThread();
          threadId = selectedThread.id;
        }
        
        // Content and threadId captured
        
        if (!content.trim()) {
          alert('Please add some content to your note');
          return;
        }
        
        // Set submitting state
        if (alpineData) {
          alpineData.isSubmitting = true;
        }
        
        try {
          const formData = new FormData(form);
          
          // Ensure content and threadId are properly set in form data
          formData.set('content', content);
          if (threadId) {
            formData.set('threadId', threadId);
          }
          
          // Form data prepared
          
          const response = await fetch(form.action, {
            method: 'POST',
            body: formData,
            credentials: 'include'
          });
          
          if (response.ok) {
            const result = await response.json();
            
            window.dispatchEvent(new CustomEvent('toast', {
              detail: {
                message: result.success || 'Note created successfully!',
                type: 'success'
              }
            }));
            
            // Dispatch note created event for navigation tracking
            window.dispatchEvent(new CustomEvent('noteCreated', {
              detail: { note: result.note }
            }));
            
            // Navigate to the newly created note
            if (result.note && result.note.id) {
              // Small delay to show the toast before navigation
              setTimeout(() => {
                window.location.href = `/${result.note.id}`;
              }, 1000);
            }
            
            // Reset form
            if (alpineData) {
              alpineData.title = '';
              alpineData.content = '';
              alpineData.selectedThread = 'Unorganized';
              alpineData.isSubmitting = false;
              // Refresh the next note ID after successful creation
              if (alpineData.loadNextNoteId) {
                // Add a small delay to ensure the database transaction is committed
                setTimeout(() => {
                  alpineData.loadNextNoteId();
                }, 200);
              }
              if (alpineData.closePanel) {
                alpineData.closePanel();
              }
            }
            
            // Clear localStorage
            localStorage.removeItem('newNoteTitle');
            localStorage.removeItem('newNoteThread');
            localStorage.removeItem('newNoteContent');
            
          } else {
            const error = await response.json();
            
            window.dispatchEvent(new CustomEvent('toast', {
              detail: {
                message: error.error || 'Error creating note',
                type: 'error'
              }
            }));
            
            if (alpineData) {
              alpineData.isSubmitting = false;
            }
          }
        } catch (error) {
          window.dispatchEvent(new CustomEvent('toast', {
            detail: {
              message: 'Error creating note. Please try again.',
              type: 'error'
            }
          }));
          
          if (alpineData) {
            alpineData.isSubmitting = false;
          }
        }
      });
    }
  }
  
  // Setup create note button on DOM ready and page load
  document.addEventListener('DOMContentLoaded', setupCreateNoteButton);
  document.addEventListener('astro:after-swap', () => {
    setTimeout(setupCreateNoteButton, 50);
  });
</script>



<style>
  /* SpaceButton styling for dropdown items */
  .space-button {
    will-change: transform;
    transition: box-shadow 0.125s ease-in-out;
  }

  .space-button[style*="background-image"] {
    box-shadow: 0px -3px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:not([data-outer-shadow]):active {
    filter: brightness(0.97);
    box-shadow: 
      0px -1px 0px 0px rgba(120, 118, 111, 0.2) inset,
      0px 1px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:active > div {
    translate: 0 0;
    transform: scale(0.98);
  }

  /* Custom QuillEditor styling for NewNotePanel - Match note content styling */
  .new-note-panel .ql-editor {
    font-family: var(--font-sans) !important;
    font-weight: normal;
    font-size: 16px;
    color: var(--color-deep-grey);
    line-height: 1.6;
    border: none !important;
    border-radius: 0 !important;
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    min-height: 200px;
  }
  
  /* Force Reddit Sans on all Quill content in NewNotePanel */
  .new-note-panel .ql-editor * {
    font-family: var(--font-sans) !important;
  }
  
  /* Override Quill's default font styles in NewNotePanel */
  .new-note-panel .ql-editor p,
  .new-note-panel .ql-editor div,
  .new-note-panel .ql-editor span,
  .new-note-panel .ql-editor strong,
  .new-note-panel .ql-editor em,
  .new-note-panel .ql-editor u {
    font-family: var(--font-sans) !important;
  }
  
  /* Custom prose-like styling to match note content */
  .new-note-panel .ql-editor {
    max-width: none;
  }
  
  /* Ensure paragraphs have proper spacing like note content */
  .new-note-panel .ql-editor p {
    margin-bottom: 0 !important;
  }
  
  .new-note-panel .ql-editor p:not(:last-child) {
    margin-bottom: 1rem !important;
  }

  .new-note-panel .ql-toolbar {
    border: none !important;
    background: white !important;
  }

  .new-note-panel .ql-container {
    border: none !important;
    background: white !important;
  }

  /* Hide duplicate toolbars - more aggressive */
  .new-note-panel .ql-toolbar:not(:first-child) {
    display: none !important;
  }
  
  /* Global rule to hide any duplicate Quill toolbars */
  .ql-toolbar:not(:first-child) {
    display: none !important;
  }
  
  /* Force Reddit Sans on all Quill editors - more aggressive */
  .new-note-panel .ql-editor,
  .new-note-panel .ql-editor *,
  .new-note-panel .ql-editor p,
  .new-note-panel .ql-editor div,
  .new-note-panel .ql-editor span,
  .new-note-panel .ql-editor strong,
  .new-note-panel .ql-editor em,
  .new-note-panel .ql-editor u,
  .new-note-panel .ql-editor ol,
  .new-note-panel .ql-editor ul,
  .new-note-panel .ql-editor li {
    font-family: var(--font-sans) !important;
    font-size: 16px !important;
    line-height: 1.6 !important;
    color: var(--color-deep-grey) !important;
  }
  
  /* Global rule to force Reddit Sans on all Quill editors */
  .ql-editor,
  .ql-editor * {
    font-family: var(--font-sans) !important;
    font-size: 16px !important;
    line-height: 1.6 !important;
    color: var(--color-deep-grey) !important;
  }

  /* HTMX loading states */
  .htmx-request #create-note-btn {
    opacity: 0.7;
    pointer-events: none;
  }

  .htmx-request #create-note-btn span:first-child {
    display: none;
  }

  .htmx-request #create-note-btn span:last-child {
    display: block;
  }
</style>
