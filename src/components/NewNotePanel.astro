---
import SquareButton from "./SquareButton.astro";
import CardFull from "./CardFull.astro";
import Button from "./Button.astro";
import SpaceButton from "./SpaceButton.astro";
import QuillEditor from "./QuillEditor.astro";
import Toast from "./Toast-v2.astro";
// Sample data imports removed - using real database data only
import { getThreadGradientCSS } from "@/utils/colors";
import { notes } from "@/actions/notes";
import { getAllThreadsWithCounts } from "@/utils/dashboard-data";

export interface Props {
  onClose?: () => void;
  currentThread?: any;
}

const { onClose, currentThread = null } = Astro.props;

// Get user ID from Clerk authentication
const { userId } = Astro.locals.auth();
// Debug logs removed for cleaner console output

if (!userId) {
  return Astro.redirect('/sign-in');
}

// Note: Thread options will be loaded dynamically via API in x-init
---

<form 
  action="/api/notes/create"
  method="POST"
  class="new-note-panel h-full flex flex-col"
  data-current-thread-title={currentThread?.title || ''}
  data-current-thread-id={currentThread?.id || ''}
  x-bind:action="'/api/notes/create'"
  x-data="{ 
    title: localStorage.getItem('newNoteTitle') || '',
    content: localStorage.getItem('newNoteContent') || '',
    selectedThread: localStorage.getItem('newNoteThread') || 'Unorganized',
    isOpen: false,
    isSubmitting: false,
    nextNoteId: '#New',
    threadOptions: [
      {
        id: 'thread_unorganized',
        title: 'Unorganized',
        color: null,
        noteCount: 0,
        backgroundGradient: 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)'
      }
    ],
    getSelectedThread() {
      return this.threadOptions.find(thread => thread.title === this.selectedThread) || this.threadOptions[0];
    },
    submitForm() {
      this.isSubmitting = true;
    },
    closePanel() {
      localStorage.removeItem('newNoteTitle');
      localStorage.removeItem('newNoteThread');
      localStorage.removeItem('newNoteContent');
      this.title = '';
      this.content = '';
      this.selectedThread = 'Unorganized';
      this.isSubmitting = false;
      window.dispatchEvent(new CustomEvent('closeNewNotePanel'));
    },
    async loadThreads() {
      try {
        const response = await fetch('/api/threads/list', {
          credentials: 'include'
        });
        
        if (response.ok) {
          const threads = await response.json();
          
          this.threadOptions = threads.map(thread => ({
            id: thread.id,
            title: thread.title,
            color: thread.color,
            noteCount: thread.noteCount,
            backgroundGradient: thread.backgroundGradient
          }));
          
          // Ensure 'Unorganized' thread exists
          const hasUnorganizedThread = this.threadOptions.some(thread => thread.title === 'Unorganized');
          if (!hasUnorganizedThread) {
            this.threadOptions.unshift({
              id: 'thread_unorganized',
              title: 'Unorganized',
              color: null,
              noteCount: 0,
              backgroundGradient: 'linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)'
            });
          }
        } else {
          console.error('API request failed:', response.status, response.statusText);
        }
      } catch (error) {
        console.error('Error loading threads:', error);
      }
    },
    async refreshThreads() {
      await this.loadThreads();
    },
    async loadNextNoteId() {
      try {
        const response = await fetch('/api/notes/next-id', {
          credentials: 'include'
        });
        
        if (response.ok) {
          const data = await response.json();
          this.nextNoteId = `#${data.formattedId}`;
        } else {
          console.error('Next note ID API request failed:', response.status, response.statusText);
          this.nextNoteId = '#New';
        }
      } catch (error) {
        console.error('Error loading next note ID:', error);
        this.nextNoteId = '#New';
      }
    }
  }"
  x-init="
    // Load next note ID from API
    loadNextNoteId();
    
    // Load threads from API
    loadThreads();
    
    // Save form data to localStorage when it changes
    $watch('title', value => localStorage.setItem('newNoteTitle', value));
    $watch('content', value => localStorage.setItem('newNoteContent', value));
    $watch('selectedThread', value => localStorage.setItem('newNoteThread', value));
    
    // Clear form when panel is opened
    window.addEventListener('openNewNotePanel', () => {
      title = '';
      content = '';
      isSubmitting = false;
      localStorage.removeItem('newNoteTitle');
      localStorage.removeItem('newNoteContent');
      
      // Refresh the next note ID when panel opens
      loadNextNoteId();
      
      // Trigger pre-selection logic when panel opens
      setTimeout(() => {
        // Call the global updateThreadSelection function directly
        if (typeof window.updateThreadSelection === 'function') {
          window.updateThreadSelection();
        }
        
        // Focus the content area after everything is loaded
        setTimeout(() => {
          const quillContainer = document.querySelector('#static-quill-container-new-note-content');
          if (quillContainer && quillContainer.__quill) {
            quillContainer.__quill.focus();
          }
        }, 200);
      }, 100);
    });
    
    // Also handle mobile drawer opening
    window.addEventListener('openMobileDrawer', (event) => {
      if (event.detail && event.detail.type === 'note') {
        // Small delay to ensure Alpine.js is fully initialized
        setTimeout(() => {
          // Refresh the next note ID when mobile drawer opens
          loadNextNoteId();
          
          // Trigger pre-selection logic when mobile drawer opens
          setTimeout(() => {
            // Call the global updateThreadSelection function directly
            if (typeof window.updateThreadSelection === 'function') {
              window.updateThreadSelection();
            }
            
            // Focus the content area after everything is loaded
            setTimeout(() => {
              const quillContainer = document.querySelector('#static-quill-container-new-note-content');
              if (quillContainer && quillContainer.__quill) {
                quillContainer.__quill.focus();
              }
            }, 200);
          }, 100);
        }, 50);
      }
    });
    
    // Listen for new thread creation to refresh the dropdown
    window.addEventListener('threadCreated', (event) => {
      refreshThreads().then(() => {
        // If a new thread was created, pre-select it
        if (event.detail && event.detail.thread && event.detail.thread.title) {
          selectedThread = event.detail.thread.title;
          localStorage.setItem('newNoteThread', event.detail.thread.title);
        }
      });
    });
    
  "

>
  <!-- Hidden form fields -->

  <input type="hidden" name="threadId" x-bind:value="getSelectedThread().id" />
  <input type="hidden" name="title" x-model="title" />

  <!-- Thread Selection using SpaceButton dropdown variant -->
  <div class="mb-3.5 shrink-0">
    <div class="relative">
      <div 
        @click.prevent.stop="isOpen = !isOpen"
        class="w-full cursor-pointer"
        tabindex="1"
      >
        <SpaceButton 
          text=""
          state="DropdownTrigger"
          count={0}
          className="w-full"
          backgroundGradient="linear-gradient(180deg, var(--color-paper) 0%, var(--color-paper) 100%)"
          isActive={false}
          x-bind:style="`background-image: ${getSelectedThread().backgroundGradient};`"
        >
          <span slot="text" x-text="selectedThread" class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap">Unorganized</span>
          <span slot="count" x-text="getSelectedThread().noteCount" class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]">0</span>
        </SpaceButton>
      </div>
      
      <!-- Dropdown content -->
      <div 
        x-show="isOpen"
        x-transition:enter="transition ease-out duration-200"
        x-transition:enter-start="opacity-0 transform scale-95"
        x-transition:enter-end="opacity-100 transform scale-100"
        x-transition:leave="transition ease-in duration-150"
        x-transition:leave-start="opacity-100 transform scale-100"
        x-transition:leave-end="opacity-0 transform scale-95"
        class="absolute top-full left-0 right-0 mt-2 z-10"
        style="min-width: 223px;"
        @click.outside="isOpen = false"
      >
        <!-- Thread options using SpaceButton styling -->
        <div>
          <template x-for="thread in threadOptions" :key="thread.id">
            <button 
              type="button"
              @click="selectedThread = thread.title; isOpen = false"
              class="space-button relative rounded-xl h-[64px] cursor-pointer transition-[scale,shadow] duration-300 pl-4 pr-0 w-full"
              x-bind:style="`background-image: ${thread.backgroundGradient};`"
            >
              <div class="flex items-center justify-between relative w-full h-full pl-2 pr-0 transition-transform duration-125">
                <span class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap" x-text="thread.title"></span>
                <div class="p-[20px]">
                  <div class="bg-[rgba(120,118,111,0.1)] flex items-center justify-center rounded-3xl w-6 h-6">
                    <span class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]" x-text="thread.noteCount">
                    </span>
                  </div>
                </div>
              </div>
            </button>
          </template>
          

        </div>
      </div>
    </div>
  </div>

  <!-- Note Content using CardFull-style form -->
  <div class="flex-1 flex flex-col min-h-0 mb-3.5">
    <div class="bg-white box-border flex flex-col h-full items-start justify-between overflow-clip pb-3 pt-6 px-3 relative rounded-[24px] shadow-[0px_3px_20px_0px_rgba(120,118,111,0.1)]">
    <!-- Header with title input and bookmark icon (like CardFull) -->
    <div class="flex gap-3 items-center justify-center px-3 py-0 relative shrink-0 w-full">
      <div class="basis-0 font-sans font-semibold grow leading-[0] min-h-px min-w-px not-italic relative shrink-0 text-[var(--color-deep-grey)] text-[24px]">
        <input 
          type="text"
          x-model="title"
          placeholder="Note title"
          tabindex="2"
          class="w-full bg-transparent border-none text-[24px] font-semibold text-[var(--color-deep-grey)] focus:outline-none placeholder-[var(--color-pebble-grey)]"
        />
      </div>
      <div class="relative shrink-0 size-5">
        <svg class="block max-w-none size-full text-[var(--color-deep-grey)] " fill="currentColor" viewBox="0 0 24 24">
          <path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z"/>
        </svg>
      </div>
    </div>
    
    <!-- Content area with QuillEditor -->
    <div class="flex-1 px-3 py-0 relative w-full" style="margin-bottom: 12px; margin-top: 20px;">
      <div class="quill-constrained-container flex-1 flex flex-col" style="height: 100%; max-height: 100%; overflow: hidden; display: flex; flex-direction: column;">
        <QuillEditor 
          content=""
          id="new-note-content"
          name="content"
          placeholder="Start writing your note..."
          tabindex={3}
        />
      </div>
    </div>

    <!-- Date and Note ID (like CardFull) -->
    <div class="flex font-sans font-normal items-center justify-between leading-[0] not-italic px-3 py-0 relative shrink-0 text-[var(--color-stone-grey)] text-[12px] text-nowrap w-full">
      <div class="relative shrink-0">
        <p class="leading-[normal] text-nowrap whitespace-pre">Today</p>
      </div>
      <div class="relative shrink-0">
        <p class="leading-[normal] text-nowrap whitespace-pre" id="new-note-id" x-text="nextNoteId">#New</p>
      </div>
    </div>
    
  </div>
  </div>

  <!-- Bottom buttons -->
  <div class="flex items-center justify-between gap-3 shrink-0">
    <div id="close-new-note-btn" @click.prevent="closePanel()" tabindex="5">
      <SquareButton variant="Close" type="button" />
    </div>
    <Button 
      state="Default"
      type="button"
      id="create-note-btn"
      class="flex-1"
      tabindex="4"
      x-bind:disabled="isSubmitting"
    >
      <span x-show="!isSubmitting">Create Note</span>
      <span x-show="isSubmitting">Creating...</span>
    </Button>
  </div>
</form>

<!-- Toast component is included in Layout.astro -->

<script>
  // Following Astro MCP best practices for View Transitions lifecycle events
  // Using astro:after-swap for immediate DOM access after content swap
  document.addEventListener('astro:after-swap', () => {
    updateThreadSelection();
  });
  
  // Also listen to astro:page-load as backup (runs after scripts are executed)
  document.addEventListener('astro:page-load', () => {
    // Use a small delay to ensure Alpine.js is fully initialized
    setTimeout(updateThreadSelection, 100);
  });
  
  // Also listen to popstate for browser back/forward navigation
  window.addEventListener('popstate', () => {
    setTimeout(updateThreadSelection, 100);
  });
  
  
  // Centralized function to update thread selection following Alpine.js best practices
  function updateThreadSelection(attempt = 1) {
    const currentPath = window.location.pathname;
    
    // Find the NewNotePanel form element
    const form = document.querySelector('.new-note-panel') as any;
    if (!form) {
      if (attempt < 5) {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
      return;
    }
    
    // Debug logging for search page issues
    if (currentPath === '/search') {
      console.log('NewNotePanel: On search page, defaulting to Unorganized thread');
    }
    
    // Get Alpine.js data using proper Alpine.js API
    let alpineData;
    try {
      // Use Alpine's $data method for proper data access
      alpineData = (window as any).Alpine?.$data(form);
    } catch (e) {
      if (attempt < 5) {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
      return;
    }
    
    if (!alpineData) {
      if (attempt < 5) {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
      return;
    }
    
    let selectedThread = null;
    let updated = false;
    
    if (currentPath.includes('/thread_')) {
      // For thread pages, get title from CardStack header (p element)
      const threadTitleElement = document.querySelector('div[style*="background-color"] p');
      if (threadTitleElement && threadTitleElement.textContent) {
        const threadTitle = threadTitleElement.textContent.trim();
        if (threadTitle && threadTitle !== 'Dashboard') {
          selectedThread = threadTitle;
          updated = true;
        }
      }
    } else if (currentPath.includes('/note_')) {
      // For note pages, use data attribute from currentThread prop
      const currentThreadTitle = form.dataset.currentThreadTitle;
      if (currentThreadTitle && currentThreadTitle.trim()) {
        selectedThread = currentThreadTitle;
        updated = true;
      }
    } else if (currentPath === '/dashboard' || currentPath === '/' || currentPath === '/search') {
      // If on dashboard or search page, default to Unorganized
      selectedThread = 'Unorganized';
      updated = true;
    }
    
    // Update Alpine.js data if we found a thread
    if (selectedThread && updated) {
      alpineData.selectedThread = selectedThread;
      localStorage.setItem('newNoteThread', selectedThread);
    } else if (!updated && attempt < 5) {
      // If we still haven't found a thread, default to Unorganized
      if (attempt === 4) {
        alpineData.selectedThread = 'Unorganized';
        localStorage.setItem('newNoteThread', 'Unorganized');
      } else {
        setTimeout(() => updateThreadSelection(attempt + 1), 200 * attempt);
      }
    }
  }
  
  // Make the function available globally
  (window as any).updateThreadSelection = updateThreadSelection;
  
  
  // MutationObserver for dynamic attribute changes (following Alpine.js best practices)
  let observer: MutationObserver | null = null;
  
  function setupMutationObserver() {
    if (observer) {
      observer.disconnect();
    }
    
    const form = document.querySelector('.new-note-panel');
    if (!form) return;
    
    observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'data-current-thread-title') {
          const currentPath = window.location.pathname;
          const currentThreadTitle = (mutation.target as any).dataset.currentThreadTitle;
          
          if (currentPath.includes('/note_') && currentThreadTitle) {
            // Get Alpine.js data using proper API
            let alpineData;
            try {
              alpineData = (window as any).Alpine?.$data(mutation.target);
            } catch (e) {
              return;
            }
            
            if (alpineData) {
              alpineData.selectedThread = currentThreadTitle;
              localStorage.setItem('newNoteThread', currentThreadTitle);
            }
          }
        }
      });
    });
    
    // Start observing the form element for attribute changes
    observer.observe(form, {
      attributes: true,
      attributeFilter: ['data-current-thread-title']
    });
  }
  
  // Setup mutation observer following Astro best practices
  document.addEventListener('DOMContentLoaded', setupMutationObserver);
  document.addEventListener('astro:after-swap', () => {
    setTimeout(setupMutationObserver, 50);
  });
  
  // Setup create note button handler
  function setupCreateNoteButton() {
    // Check if listener already added to prevent duplicates
    if ((window as any).noteCreationListenerAdded) {
      console.log('Note creation listener already added, skipping');
      return;
    }
    
    const createBtn = document.getElementById('create-note-btn');
    if (createBtn) {
      createBtn.addEventListener('click', async (e) => {
        e.preventDefault(); // Prevent default form submission
        const form = document.querySelector('form');
        if (!form) return;
        
        let alpineData;
        try {
          alpineData = (window as any).Alpine?.$data(form);
        } catch (e) {
          // Alpine data not available
        }
        
        // Get content from StaticQuill Editor
        let content = '';
        const quillContainer = document.querySelector('#static-quill-container-new-note-content') as any;
        const hiddenInput = document.querySelector('input[name="content"]') as HTMLInputElement;
        
        
        // Try to get content from hidden input first (most reliable)
        if (hiddenInput && hiddenInput.value) {
          content = hiddenInput.value;
        }
        
        // Fallback to Quill Editor
        if (!content && quillContainer && quillContainer.__quill) {
          try {
            content = quillContainer.__quill.root.innerHTML;
          } catch (error) {
            console.error('Error getting content from Quill Editor:', error);
          }
        }
        
        // Fallback to Alpine data
        if (!content && alpineData?.content) {
          content = alpineData.content;
        }
        
        // Get threadId from Alpine data to ensure it's correct
        let threadId = '';
        if (alpineData && alpineData.getSelectedThread) {
          const selectedThread = alpineData.getSelectedThread();
          threadId = selectedThread.id;
        }
        
        // Content and threadId captured
        console.log('Content validation:', {
          content: content,
          contentLength: content.length,
          contentTrimmed: content.trim(),
          contentTrimmedLength: content.trim().length
        });
        
        if (!content.trim()) {
          console.log('Content is empty, showing alert');
          alert('Please add some content to your note');
          return;
        }
        
        // Set submitting state
        if (alpineData) {
          alpineData.isSubmitting = true;
        }
        
        try {
          const formData = new FormData(form);
          
          // Ensure content and threadId are properly set in form data
          formData.set('content', content);
          if (threadId) {
            formData.set('threadId', threadId);
          }
          
          // Ensure we're using the correct API endpoint
          const apiEndpoint = '/api/notes/create';
          form.action = apiEndpoint;
          
          console.log('Form data prepared:', {
            content: content.substring(0, 50) + '...',
            threadId: threadId,
            title: formData.get('title'),
            action: form.action,
            apiEndpoint: apiEndpoint
          });
          
          const response = await fetch(apiEndpoint, {
            method: 'POST',
            body: formData,
            credentials: 'include'
          });
          
          console.log('API response status:', response.status);
          
          if (response.ok) {
            const result = await response.json();
            
            window.dispatchEvent(new CustomEvent('toast', {
              detail: {
                message: result.success || 'Note created successfully!',
                type: 'success'
              }
            }));
            
            // Dispatch note created event for navigation tracking
            window.dispatchEvent(new CustomEvent('noteCreated', {
              detail: { note: result.note }
            }));
            
            // Navigate to the newly created note
            if (result.note && result.note.id) {
              // Small delay to show the toast before navigation
              setTimeout(() => {
                window.location.href = `/${result.note.id}`;
              }, 1000);
            }
            
            // Reset form
            if (alpineData) {
              alpineData.title = '';
              alpineData.content = '';
              alpineData.selectedThread = 'Unorganized';
              alpineData.isSubmitting = false;
              // Refresh the next note ID after successful creation
              if (alpineData.loadNextNoteId) {
                // Add a small delay to ensure the database transaction is committed
                setTimeout(() => {
                  alpineData.loadNextNoteId();
                }, 200);
              }
              if (alpineData.closePanel) {
                alpineData.closePanel();
              }
            }
            
            // Clear localStorage
            localStorage.removeItem('newNoteTitle');
            localStorage.removeItem('newNoteThread');
            localStorage.removeItem('newNoteContent');
            
          } else {
            const error = await response.json();
            
            window.dispatchEvent(new CustomEvent('toast', {
              detail: {
                message: error.error || 'Error creating note',
                type: 'error'
              }
            }));
            
            if (alpineData) {
              alpineData.isSubmitting = false;
            }
          }
        } catch (error: any) {
          console.error('Error in note creation process:', error);
          
          window.dispatchEvent(new CustomEvent('toast', {
            detail: {
              message: `Error creating note: ${(error as Error)?.message || 'Please try again.'}`,
              type: 'error'
            }
          }));
          
          if (alpineData) {
            alpineData.isSubmitting = false;
          }
        }
      });
      
      // Mark that listener has been added
      (window as any).noteCreationListenerAdded = true;
    }
  }
  
  // Define global noteSaveCallback function for QuillEditor compatibility
  (window as any).noteSaveCallback = async function(title: string, content: string) {
    console.log('noteSaveCallback called with:', { title, content });
    // This is a placeholder - the actual save logic is handled by the form submission
    return { success: true };
  };

  // Setup create note button on DOM ready and page load
  document.addEventListener('DOMContentLoaded', setupCreateNoteButton);
  document.addEventListener('astro:after-swap', () => {
    // Reset the listener flag on page transitions to allow re-setup
    (window as any).noteCreationListenerAdded = false;
    setTimeout(setupCreateNoteButton, 50);
  });
  
  // Also setup when mobile drawer opens (for mobile usage)
  document.addEventListener('openMobileDrawer', (event) => {
    if ((event as CustomEvent).detail?.type === 'note') {
      setTimeout(setupCreateNoteButton, 100);
    }
  });
  
  // Make setupCreateNoteButton globally available
  (window as any).setupCreateNoteButton = setupCreateNoteButton;
</script>



<style>
  /* SpaceButton styling for dropdown items */
  .space-button {
    will-change: transform;
    transition: box-shadow 0.125s ease-in-out;
  }

  .space-button[style*="background-image"] {
    box-shadow: 0px -3px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:not([data-outer-shadow]):active {
    filter: brightness(0.97);
    box-shadow: 
      0px -1px 0px 0px rgba(120, 118, 111, 0.2) inset,
      0px 1px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:active > div {
    translate: 0 0;
    transform: scale(0.98);
  }

  /* NewNotePanel height constraints */
  .new-note-panel {
    height: 100% !important;
    display: flex !important;
    flex-direction: column !important;
  }

  /* Custom QuillEditor styling for NewNotePanel - Match note content styling */
  .new-note-panel .ql-editor {
    font-family: var(--font-sans) !important;
    font-weight: normal;
    font-size: 16px;
    color: var(--color-deep-grey);
    line-height: 1.6;
    border: none !important;
    border-radius: 0 !important;
    padding: 0 !important;
    background: transparent !important;
    box-shadow: none !important;
    flex: 1 !important;
    overflow: auto !important;
    min-height: 0 !important;
    height: 0 !important;
  }
  
  /* Simple placeholder fix for NewNotePanel */
  .new-note-panel .ql-editor.ql-blank::before {
    text-indent: 0 !important;
    padding-left: 0 !important;
    font-style: normal !important;
  }
  
  /* Force Reddit Sans on all Quill content in NewNotePanel */
  .new-note-panel .ql-editor * {
    font-family: var(--font-sans) !important;
  }
  
  /* Override Quill's default font styles in NewNotePanel */
  .new-note-panel .ql-editor p,
  .new-note-panel .ql-editor div,
  .new-note-panel .ql-editor span,
  .new-note-panel .ql-editor strong,
  .new-note-panel .ql-editor em,
  .new-note-panel .ql-editor u {
    font-family: var(--font-sans) !important;
  }
  
  /* Custom prose-like styling to match note content */
  .new-note-panel .ql-editor {
    max-width: none;
  }
  
  /* Ensure paragraphs have proper spacing like note content */
  .new-note-panel .ql-editor p {
    margin-bottom: 0 !important;
  }
  
  .new-note-panel .ql-editor p:not(:last-child) {
    margin-bottom: 1rem !important;
  }

  .new-note-panel .ql-toolbar {
    border: none !important;
    background: transparent !important;
    display: flex !important;
    gap: 0.5rem !important;
    align-items: center !important;
    padding: 0.5rem 0 !important;
  }
  
  .new-note-panel .ql-toolbar button {
    background: transparent !important;
    border: none !important;
    border-radius: 0.75rem !important;
    padding: 0.5rem 0.75rem !important;
    margin: 0 !important;
    color: var(--color-deep-grey) !important;
    font-family: var(--font-sans) !important;
    font-size: 14px !important;
    font-weight: 600 !important;
    transition: all 0.125s ease-in-out !important;
    min-height: 2rem !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
  }
  
  .new-note-panel .ql-toolbar button:hover {
    background: var(--color-fog-white) !important;
    box-shadow: 0px -3px 0px 0px rgba(120, 118, 111, 0.2) inset !important;
  }
  
  .new-note-panel .ql-toolbar button.ql-active {
    background: var(--color-fog-white) !important;
    box-shadow: 0px -3px 0px 0px rgba(120, 118, 111, 0.2) inset !important;
  }

  .new-note-panel .ql-container {
    border: none !important;
    background: white !important;
    height: 100% !important;
    max-height: 100% !important;
    overflow: hidden !important;
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
  }

  /* QuillEditor root container */
  .new-note-panel #static-quill-editor {
    height: 100% !important;
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
    min-height: 0 !important;
  }

  /* QuillEditor content container */
  .new-note-panel .quill-content {
    height: 100% !important;
    max-height: 100% !important;
    overflow: hidden !important;
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
  }

  /* Ensure the white card container respects height constraints */
  .new-note-panel .bg-white {
    height: 100% !important;
    max-height: 100% !important;
    overflow: hidden !important;
    display: flex !important;
    flex-direction: column !important;
  }

  /* Quill constrained container for NewNotePanel */
  .new-note-panel .quill-constrained-container {
    height: 100% !important;
    max-height: 100% !important;
    overflow: hidden !important;
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
  }

  /* Force QuillEditor to respect container bounds in NewNotePanel */
  .new-note-panel .quill-constrained-container .ql-container {
    height: 100% !important;
    max-height: 100% !important;
    overflow: hidden !important;
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
  }

  .new-note-panel .quill-constrained-container .ql-editor {
    flex: 1 !important;
    overflow: auto !important;
    min-height: 0 !important;
    height: 0 !important;
  }

  /* Hide duplicate toolbars - more aggressive */
  .new-note-panel .ql-toolbar:not(:first-child) {
    display: none !important;
  }
  
  /* Global rule to hide any duplicate Quill toolbars */
  .ql-toolbar:not(:first-child) {
    display: none !important;
  }
  
  /* Force Reddit Sans on all Quill editors - more aggressive */
  .new-note-panel .ql-editor,
  .new-note-panel .ql-editor *,
  .new-note-panel .ql-editor p,
  .new-note-panel .ql-editor div,
  .new-note-panel .ql-editor span,
  .new-note-panel .ql-editor strong,
  .new-note-panel .ql-editor em,
  .new-note-panel .ql-editor u,
  .new-note-panel .ql-editor ol,
  .new-note-panel .ql-editor ul,
  .new-note-panel .ql-editor li {
    font-family: var(--font-sans) !important;
    font-size: 16px !important;
    line-height: 1.6 !important;
    color: var(--color-deep-grey) !important;
  }
  
  /* Global rule to force Reddit Sans on all Quill editors */
  .ql-editor,
  .ql-editor * {
    font-family: var(--font-sans) !important;
    font-size: 16px !important;
    line-height: 1.6 !important;
    color: var(--color-deep-grey) !important;
  }
  
  /* Simple global placeholder fix */
  .ql-editor.ql-blank::before {
    text-indent: 0 !important;
    padding-left: 0 !important;
    font-style: normal !important;
  }
  

  /* HTMX loading states */
  .htmx-request #create-note-btn {
    opacity: 0.7;
    pointer-events: none;
  }

  .htmx-request #create-note-btn span:first-child {
    display: none;
  }

  .htmx-request #create-note-btn span:last-child {
    display: block;
  }
</style>
