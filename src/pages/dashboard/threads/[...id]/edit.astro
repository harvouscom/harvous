---
import { db, eq, Threads, and } from "astro:db";
import { actions } from "astro:actions";
import { z } from "zod";
import Layout from "@/layouts/Layout.astro";
import Tab from "@/components/TabBar/Tab.astro";
import TitleInput from "@/components/TitleInput.astro";
import ThreadMetaBar from "@/components/ThreadMetaBar.astro";
import ThreadColorPicker from "@/components/ThreadColorPicker.astro";

const { id } = Astro.params;

// Validate ID parameter
if (!id || z.number({ coerce: true }).safeParse(id).success === false) {
  return Astro.redirect("/dashboard/threads");
}

const numericId = parseInt(id);
const currentUser = Astro.locals.auth();
const userId = currentUser ? currentUser.userId : null;

if (!userId) {
  return Astro.redirect("/login");
}

// Only fetch the thread if we're not already redirecting
const threads = await db
  .select()
  .from(Threads)
  .where(and(eq(Threads.id, numericId), eq(Threads.userId, userId as string)))
  .limit(1);

if (!threads.length) {
  return Astro.redirect("/dashboard/threads");
}

const thread = threads[0];

const result = Astro.getActionResult(actions.threads.update);
if (result?.data?.success && result.data.thread) {
  return Astro.redirect("/dashboard/threads/" + result.data.thread[0].id);
}

// Make sure color is string or undefined (not null)
const threadColorProp = thread.color || undefined;
---

<Layout title={thread.title || 'Edit Thread'}>
  <div class="flex flex-col h-full">
    <section class="bg-(--color-fog-white) pt-3">
      <div class="px-3 mx-auto max-w-screen-sm flex items-center">
        <div class="flex h-[48px]">
          <Tab label="Feed" href="/dashboard" />
          <Tab label="Thread" active closable color={threadColorProp} />
          <div id="note-tab-container" class="h-full"></div>
          <Tab label="Profile" href="/dashboard/profile" />
        </div>
      </div>
    </section>

    <main class="flex-1 w-full max-w-screen-sm mx-auto px-3 pt-6 pb-6 flex flex-col">
      <form class="flex flex-col" method="POST" action={actions.threads.update}>
        <div class="space-y-3">
          <input
            class="title-input"
            type="text"
            name="title"
            placeholder="Thread Name"
            required
            id="title-input"
            value={thread.title}
          />
          <ThreadMetaBar threadId={thread.id} isPublic={thread.isPublic} />
          
          <div class="mt-4">
            <label class="block text-sm font-medium mb-2">Thread Color</label>
            <ThreadColorPicker selectedColor={thread.color || ""} />
          </div>
          
          <input type="hidden" name="id" value={thread.id} />
          <input type="hidden" name="isPublic" id="isPublic" value={thread.isPublic.toString()} />
          <input type="hidden" name="userId" value={userId} />
          
          <div class="py-2">
            <button
              class="w-full bg-[var(--color-blue)] text-white py-3 px-3 rounded-xl shadow-[0px_-4px_0px_0px_#0000001A_inset] h-[60px]"
              type="submit">Save</button>
          </div>
        </div>
      </form>
    </main>
  </div>
</Layout>

<style>
  .title-input {
    display: flex;
    width: 100%;
    height: 60px;
    padding: 8px 12px;
    align-items: center;
    gap: 12px;
    border-radius: 12px;
    background: var(--color-fog-white, #F7F7F6);
    border: none;
    font-family: inherit;
    font-size: 16px;
  }

  .title-input:focus {
    outline: none;
    box-shadow: 0 0 0 2px var(--color-blue, #0066FF);
  }
</style>

<script define:vars={{ threadId: thread.id, isPublic: thread.isPublic }}>
  document.addEventListener('DOMContentLoaded', () => {
    // Store the current thread ID in localStorage
    localStorage.setItem('lastViewedThread', threadId.toString());
    
    // Title Input Auto-capitalization
    const titleInput = document.getElementById('title-input');
    
    if (titleInput) {
      // Function to capitalize first letter while typing
      titleInput.addEventListener('input', function() {
        const input = this;
        const cursorPosition = input.selectionStart || 0;
        const value = input.value;
        
        // Only capitalize if we're editing the first character
        if (value && cursorPosition <= 1) {
          input.value = value.charAt(0).toUpperCase() + value.slice(1);
          
          // Restore cursor position
          input.setSelectionRange(cursorPosition, cursorPosition);
        }
      });
    }
    
    // Set up privacy toggle
    const metabarPrivacyButton = document.querySelector('.button-wrapper');
    const isPublicInput = document.getElementById('isPublic');
    
    if (metabarPrivacyButton && isPublicInput) {
      // Update the initial state
      const buttonText = metabarPrivacyButton.querySelector('p');
      if (buttonText) {
        buttonText.textContent = isPublic ? 'Public' : 'Private';
      }
      
      // Update the icon
      const buttonIcon = metabarPrivacyButton.querySelector('svg');
      if (buttonIcon) {
        // Toggle classes for the icon based on public/private state
        if (isPublic) {
          buttonIcon.classList.add('public-icon');
          buttonIcon.classList.remove('private-icon');
        } else {
          buttonIcon.classList.add('private-icon');
          buttonIcon.classList.remove('public-icon');
        }
      }
      
      // Add click listener
      metabarPrivacyButton.addEventListener('click', () => {
        const currentValue = isPublicInput.value === 'true';
        isPublicInput.value = (!currentValue).toString();
        
        // Update the button text
        if (buttonText) {
          buttonText.textContent = !currentValue ? 'Public' : 'Private';
        }
        
        // Update the icon
        if (buttonIcon) {
          // Toggle classes for the icon based on public/private state
          if (!currentValue) {
            buttonIcon.classList.add('public-icon');
            buttonIcon.classList.remove('private-icon');
          } else {
            buttonIcon.classList.add('private-icon');
            buttonIcon.classList.remove('public-icon');
          }
        }
      });
    }
    
    // Check if we should show a note tab
    const lastViewedNote = localStorage.getItem('lastViewedNote');
    if (lastViewedNote) {
      const sourceThreadForNote = localStorage.getItem('sourceThreadForNote');
      
      // Only add the note tab if it belongs to this thread
      if (sourceThreadForNote === threadId.toString()) {
        const noteTabContainer = document.getElementById('note-tab-container');
        if (noteTabContainer) {
          const noteTab = document.createElement('div');
          noteTab.style.margin = '0';
          noteTab.style.padding = '0';
          
          noteTab.innerHTML = `
            <div class="h-[48px]">
              <a href="/dashboard/notes/${lastViewedNote}?threadId=${threadId}" class="h-full rounded-t-lg bg-(--color-fog-white) flex items-center" role="tab">
                <div class="h-full flex items-center pl-[20px] pr-[12px] gap-2">
                  <span class="font-bold text-sm text-(--color-stone-grey)">Note</span>
                  <button class="w-[15px] h-[15px] flex items-center justify-center text-[15px] font-medium text-(--color-stone-grey) p-0 border-0 bg-transparent cursor-pointer" onclick="closeNoteTab(event)">Ã—</button>
                </div>
              </a>
            </div>
          `;
          noteTabContainer.appendChild(noteTab);
          
          // Define the close function
          window.closeNoteTab = function(event) {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            
            localStorage.removeItem('lastViewedNote');
            noteTabContainer.innerHTML = '';
          };
        }
      }
    }
  });
</script> 