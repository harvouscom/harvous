---
import { db, eq, Threads, and, NoteThreads, Notes } from "astro:db";
import { actions } from "astro:actions";
import { z } from "zod";
import Layout from "@/layouts/Layout.astro";
import IconButton from "@/components/IconButton.astro";
import LockIcon from "@fortawesome/fontawesome-free/svgs/solid/lock.svg";
import GlobeIcon from "@fortawesome/fontawesome-free/svgs/solid/globe.svg";
import XmarkIcon from "@fortawesome/fontawesome-free/svgs/solid/xmark.svg";
import DeleteIcon from "@fortawesome/fontawesome-free/svgs/solid/trash.svg";
import Tab from "@/components/TabBar/Tab.astro";
import ChonkButton from "@/components/ChonkButton.astro";
import NoteCard from "@/components/NoteCard.astro";
import PencilIcon from "@fortawesome/fontawesome-free/svgs/solid/pencil.svg";
import ThumbTackIcon from "@fortawesome/fontawesome-free/svgs/solid/thumbtack.svg";

const { id } = Astro.params;

// Validate ID parameter
if (!id || z.number({ coerce: true }).safeParse(id).success === false) {
  return Astro.redirect("/dashboard/threads");
}

const numericId = parseInt(id);
const currentUser = Astro.locals.auth();
const userId = currentUser ? currentUser.userId : null;

if (!userId) {
  return Astro.redirect("/login");
}

// Only fetch the thread if we're not already redirecting
const threads = await db
  .select()
  .from(Threads)
  .where(and(eq(Threads.id, numericId), eq(Threads.userId, userId as string)))
  .limit(1);

if (!threads.length) {
  return Astro.redirect("/dashboard/threads");
}

const thread = threads[0];

// Get notes for this thread
const noteThreads = await db
  .select()
  .from(NoteThreads)
  .where(eq(NoteThreads.threadId, numericId));

// Get note details
let notes = [];
if (noteThreads.length > 0) {
  for (const relation of noteThreads) {
    const noteResults = await db
      .select()
      .from(Notes)
      .where(and(
        eq(Notes.id, relation.noteId),
        eq(Notes.userId, userId as string)
      ))
      .limit(1);
    
    if (noteResults.length > 0) {
      notes.push(noteResults[0]);
    }
  }
  
  // Sort notes by creation date (newest first)
  notes.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
}
---

<Layout title="Thread">
  <div x-data="{ showActionBar: false }" class="flex flex-col min-h-[100vh] relative">
    <section class="bg-(--color-fog-white) pt-3">
      <div class="px-6 mx-auto max-w-screen-sm flex items-center">
        <div class="flex h-[48px]">
          <Tab label="Feed" href="/dashboard" />
          <Tab label="Thread" active closable />
          <div id="note-tab-container" class="h-full"></div>
        </div>
      </div>
    </section>

    <main
      class="w-full max-w-screen-sm mx-auto px-6 pt-6 flex-grow flex flex-col gap-3"
    >
      <section class="w-full px-1 py-2 flex items-center gap-2 relative">
        <button 
          class="icon-btn rounded-full w-[44px] h-[44px] flex items-center justify-center shadow-[0px_-2.91px_0px_0px_#0000001A_inset]"
          :class="showActionBar ? 'bg-[var(--color-stone-grey)] text-[var(--color-light-paper)] fill-[var(--color-light-paper)]' : 'bg-[var(--color-paper)] text-[var(--color-stone-grey)] fill-[var(--color-stone-grey)]'"
          @click="showActionBar = !showActionBar"
        >
          {thread.isPublic ? (
            <GlobeIcon x-show="!showActionBar" class="w-[20px] h-[20px]" />
          ) : (
            <LockIcon x-show="!showActionBar" class="w-[20px] h-[20px]" />
          )}
          <XmarkIcon x-cloak x-show="showActionBar" class="w-[20px] h-[20px]" />
        </button>
        <div class="flex items-center gap-2">
          {thread.color && (
            <span 
              class="w-4 h-4 rounded-full inline-block mr-1" 
              style={`background-color: var(--color-${thread.color})`}
            ></span>
          )}
          <h1 class="text-title">{thread.title || "Untitled Thread"}</h1>
        </div>
        
        <!-- Floating action bar positioned absolutely below the button -->
        <div 
          x-show="showActionBar" 
          x-cloak
          class="absolute top-[64px] left-[-12px] right-[-12px] z-10 bg-(--color-pebble-grey) p-3 rounded-xl shadow-lg"
        >
          <div class="grid grid-cols-3 gap-3 w-full">
            <a class="grid" href={`/dashboard/threads/${thread.id}/edit`}>
              <ChonkButton text="Edit Thread">
                <PencilIcon class="w-[15px] h-[15px] text-inherit fill-current" />
              </ChonkButton>
            </a>
            <form 
              id="pinForm" 
              class="grid" 
              method="POST" 
              action="/api/threads/toggle-pin"
            >
              <input type="hidden" name="id" value={thread.id.toString()} />
              <input type="hidden" name="userId" value={userId} />
              <button type="submit" style="width: 100%; height: 100%; padding: 0; background: none; border: none;">
                <ChonkButton text={thread.isPinned ? "Unpin" : "Pin"}>
                  <ThumbTackIcon class="w-[15px] h-[15px] text-inherit fill-current" />
                </ChonkButton>
              </button>
            </form>
            <form 
              id="deleteForm" 
              class="grid" 
              method="POST" 
              action={actions.threads.delete}
            >
              <input type="hidden" name="id" value={thread.id} />
              <input type="hidden" name="userId" value={userId} />
              <button type="submit" style="width: 100%; height: 100%; padding: 0; background: none; border: none;">
                <ChonkButton text="Delete">
                  <DeleteIcon class="w-[15px] h-[15px] text-inherit fill-current" />
                </ChonkButton>
              </button>
            </form>
          </div>
        </div>
      </section>

      <section class="w-full p-6 bg-(--color-light-paper) rounded-xl">
        <div class="flex justify-between items-center mb-4">
          <div>
            <p class="text-sm text-gray-500">Created: {thread.createdAt.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</p>
            {thread.updatedAt && (
              <p class="text-sm text-gray-500">Updated: {thread.updatedAt.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</p>
            )}
          </div>
          <div class="text-sm bg-(--color-paper) py-1 px-3 rounded-full">
            {thread.isPublic ? 'Public' : 'Private'}
          </div>
        </div>
      </section>

      <div class="mt-4 p-4 bg-[var(--color-fog-white)] rounded-xl">
        <h2 class="text-lg font-medium mb-4">Notes in this thread ({notes.length})</h2>
        {notes.length === 0 ? (
          <div class="text-center py-8 text-gray-500">
            <p>This thread doesn't have any notes yet.</p>
            <p class="mt-2">Add notes to this thread to start organizing your content.</p>
          </div>
        ) : (
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
            {notes.map((note) => (
              <a href={`/dashboard/notes/${note.id}?threadId=${thread.id}`} class="block">
                <NoteCard 
                  title={note.title || ''} 
                  content={note.content} 
                />
              </a>
            ))}
          </div>
        )}
      </div>
    </main>
  </div>
</Layout>

<script define:vars={{ threadId: thread.id, noteIds: notes.map(note => note.id) }}>
  document.addEventListener('DOMContentLoaded', () => {
    // Store the current thread ID in localStorage
    localStorage.setItem('lastViewedThread', threadId.toString());
    
    // Update the source thread for any currently viewed note
    const lastViewedNote = localStorage.getItem('lastViewedNote');
    if (lastViewedNote) {
      localStorage.setItem('sourceThreadForNote', threadId.toString());
      
      // Check if we should show a note tab
      if (noteIds.includes(parseInt(lastViewedNote))) {
        const noteTabContainer = document.getElementById('note-tab-container');
        if (noteTabContainer) {
          const noteTab = document.createElement('div');
          noteTab.style.margin = '0';
          noteTab.style.padding = '0';
          
          noteTab.innerHTML = `
            <div class="h-[48px]">
              <a href="/dashboard/notes/${lastViewedNote}?threadId=${threadId}" class="h-full rounded-t-lg bg-(--color-fog-white) flex items-center" role="tab">
                <div class="h-full flex items-center pl-[20px] pr-[12px] gap-2">
                  <span class="font-bold text-sm text-(--color-stone-grey)">Note</span>
                  <button class="w-[15px] h-[15px] flex items-center justify-center text-[15px] font-medium text-(--color-stone-grey) p-0 border-0 bg-transparent cursor-pointer" onclick="closeNoteTab()">Ã—</button>
                </div>
              </a>
            </div>
          `;
          noteTabContainer.appendChild(noteTab);
        }
      }
    }
    
    // Handle form submission for pin toggle
    const pinForm = document.querySelector('#pinForm');
    if (pinForm) {
      pinForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Create FormData and log its contents for debugging
        const formData = new FormData(pinForm);
        console.log('Submitting form with data:');
        for (let [key, value] of formData.entries()) {
          console.log(`${key}: ${value}`);
        }
        
        // Submit form data via fetch
        fetch(pinForm.action, {
          method: 'POST',
          body: formData,
          headers: {
            'Accept': 'application/json'
          }
        })
        .then(response => {
          console.log('Response status:', response.status);
          // Log the raw response for debugging
          return response.text().then(text => {
            console.log('Raw response:', text);
            // Try to parse as JSON
            try {
              return text ? JSON.parse(text) : {};
            } catch (err) {
              console.error('Error parsing JSON:', err);
              // Return an error object directly instead of throwing
              return { error: 'Failed to parse server response' };
            }
          });
        })
        .then(data => {
          console.log('Response data:', data);
          if (data.success) {
            // Update the button text without reloading
            const pinButton = pinForm.querySelector('button span');
            if (pinButton) {
              pinButton.textContent = data.thread?.isPinned ? "Unpin" : "Pin";
            }
            
            // Show a toast notification
            window.dispatchEvent(new CustomEvent('toast', { 
              detail: { 
                message: data.success,
                type: 'info'
              } 
            }));
            
            // Hide the action bar (without Alpine direct access)
            document.querySelector('.icon-btn')?.click();
          } else if (data.error) {
            // Handle error from the parsed data
            window.dispatchEvent(new CustomEvent('toast', { 
              detail: { 
                message: 'Error: ' + data.error,
                type: 'error'
              } 
            }));
          }
        })
        .catch(error => {
          console.error('Fetch error:', error);
          // Show error toast
          window.dispatchEvent(new CustomEvent('toast', { 
            detail: { 
              message: 'Failed to update pin status: Network or fetch error',
              type: 'error'
            } 
          }));
        });
      });
    }
    
    // Handle form submission for delete
    const deleteForm = document.querySelector('#deleteForm');
    if (deleteForm) {
      deleteForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Clear localStorage
        localStorage.removeItem('lastViewedThread');
        localStorage.removeItem('sourceThreadForNote');
        
        // Submit form data via fetch
        fetch(deleteForm.action, {
          method: 'POST',
          body: new FormData(deleteForm)
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            // Redirect to dashboard
            window.location.href = '/dashboard';
          }
        })
        .catch(error => {
          console.error('Error:', error);
          // Redirect anyway on error
          window.location.href = '/dashboard';
        });
      });
    }
  });
  
  // Function to close note tab
  function closeNoteTab() {
    localStorage.removeItem('lastViewedNote');
    const noteTabContainer = document.getElementById('note-tab-container');
    if (noteTabContainer) {
      noteTabContainer.innerHTML = '';
    }
  }
</script> 