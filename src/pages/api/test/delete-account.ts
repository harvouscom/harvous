import type { APIRoute } from 'astro';
import { db, Notes, Threads, Spaces, Tags, NoteTags, NoteThreads, UserMetadata, UserXP, Comments, ScriptureMetadata, NoteThreadAccess, Members, eq } from 'astro:db';
import { randomUUID } from 'crypto';

/**
 * Test endpoint for delete account functionality
 * This endpoint creates test data, runs the delete account logic, and verifies deletion
 * 
 * Usage: GET /api/test/delete-account
 * 
 * Note: This creates and deletes test data with userId prefix "test_delete_"
 */

interface TestData {
  spaceId: string;
  threadId: string;
  noteIds: string[];
  tagIds: string[];
}

export const GET: APIRoute = async ({ request }) => {
  try {
    console.log('üß™ Starting delete account test...');
    
    // Use a unique test user ID
    const TEST_USER_ID = `test_delete_${Date.now()}`;
    
    // Step 1: Create test data
    console.log('üìù Creating test data...');
    const testData = await createTestData(TEST_USER_ID);
    
    // Step 2: Verify test data exists
    console.log('üîç Verifying test data...');
    const beforeCounts = await verifyTestData(TEST_USER_ID);
    
    // Step 3: Run delete account logic
    console.log('üóëÔ∏è  Running delete account logic...');
    await runDeleteAccount(TEST_USER_ID);
    
    // Step 4: Verify deletion
    console.log('‚úÖ Verifying deletion...');
    const afterCounts = await verifyTestData(TEST_USER_ID);
    
    // Check if all counts are zero
    const allDeleted = Object.values(afterCounts).every(count => count === 0);
    
    const result = {
      success: allDeleted,
      testUserId: TEST_USER_ID,
      beforeCounts,
      afterCounts,
      allDeleted,
      timestamp: new Date().toISOString()
    };
    
    if (allDeleted) {
      console.log('‚úÖ TEST PASSED: All user data successfully deleted');
      return new Response(JSON.stringify(result), {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      });
    } else {
      console.log('‚ùå TEST FAILED: Some data was not deleted');
      return new Response(JSON.stringify(result), {
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
  } catch (error: any) {
    console.error('‚ùå Test error:', error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
};

async function createTestData(userId: string): Promise<TestData> {
  const testData: TestData = {
    spaceId: '',
    threadId: '',
    noteIds: [],
    tagIds: [],
  };

  // Create a space
  const spaceId = randomUUID();
  await db.insert(Spaces).values({
    id: spaceId,
    title: 'Test Space',
    userId: userId,
    createdAt: new Date(),
    isActive: true,
    isPublic: false,
    order: 0,
  });
  testData.spaceId = spaceId;

  // Create a thread
  const threadId = randomUUID();
  await db.insert(Threads).values({
    id: threadId,
    title: 'Test Thread',
    userId: userId,
    spaceId: spaceId,
    createdAt: new Date(),
    isPublic: false,
    isPinned: false,
    order: 0,
  });
  testData.threadId = threadId;

  // Create notes
  for (let i = 0; i < 3; i++) {
    const noteId = randomUUID();
    await db.insert(Notes).values({
      id: noteId,
      title: `Test Note ${i + 1}`,
      content: `<p>Test content ${i + 1}</p>`,
      threadId: threadId,
      spaceId: spaceId,
      userId: userId,
      simpleNoteId: i + 1,
      createdAt: new Date(),
      isPublic: false,
      isFeatured: false,
      order: 0,
    });
    testData.noteIds.push(noteId);
  }

  // Create a scripture note
  const scriptureNoteId = randomUUID();
  await db.insert(Notes).values({
    id: scriptureNoteId,
    title: 'John 3:16',
    content: '<p>For God so loved the world...</p>',
    threadId: threadId,
    userId: userId,
    noteType: 'scripture',
    createdAt: new Date(),
    isPublic: false,
    isFeatured: false,
    order: 0,
  });
  testData.noteIds.push(scriptureNoteId);

  // Create tags
  for (let i = 0; i < 2; i++) {
    const tagId = randomUUID();
    await db.insert(Tags).values({
      id: tagId,
      name: `Test Tag ${i + 1}`,
      userId: userId,
      isSystem: false,
      createdAt: new Date(),
    });
    testData.tagIds.push(tagId);
  }

  // Create NoteTags relationships
  for (let i = 0; i < testData.noteIds.length; i++) {
    const noteId = testData.noteIds[i];
    const tagId = testData.tagIds[i % testData.tagIds.length];
    await db.insert(NoteTags).values({
      id: randomUUID(),
      noteId: noteId,
      tagId: tagId,
      isAutoGenerated: false,
      createdAt: new Date(),
    });
  }

  // Create NoteThreads relationships
  for (const noteId of testData.noteIds) {
    await db.insert(NoteThreads).values({
      id: randomUUID(),
      noteId: noteId,
      threadId: testData.threadId,
      createdAt: new Date(),
    });
  }

  // Create Comments
  for (const noteId of testData.noteIds.slice(0, 2)) {
    await db.insert(Comments).values({
      id: randomUUID(),
      noteId: noteId,
      userId: userId,
      content: 'Test comment',
      createdAt: new Date(),
    });
  }

  // Create ScriptureMetadata
  await db.insert(ScriptureMetadata).values({
    id: randomUUID(),
    noteId: scriptureNoteId,
    reference: 'John 3:16',
    book: 'John',
    chapter: 3,
    verse: 16,
    translation: 'NET',
    originalText: 'For God so loved the world...',
    createdAt: new Date(),
  });

  // Create NoteThreadAccess
  for (const noteId of testData.noteIds) {
    await db.insert(NoteThreadAccess).values({
      id: randomUUID(),
      userId: userId,
      noteId: noteId,
      threadId: testData.threadId,
      lastAccessed: new Date(),
      accessCount: 1,
    });
  }

  // Create Members (for the space)
  await db.insert(Members).values({
    id: randomUUID(),
    userId: userId,
    spaceId: spaceId,
    role: 'owner',
    createdAt: new Date(),
  });

  // Create UserMetadata
  await db.insert(UserMetadata).values({
    id: `user_metadata_${userId}`,
    userId: userId,
    highestSimpleNoteId: 4,
    userColor: 'paper',
    createdAt: new Date(),
  });

  // Create UserXP
  for (let i = 0; i < 3; i++) {
    await db.insert(UserXP).values({
      id: randomUUID(),
      userId: userId,
      activityType: 'note_created',
      xpAmount: 10,
      relatedId: testData.noteIds[i],
      createdAt: new Date(),
    });
  }

  return testData;
}

async function verifyTestData(userId: string) {
  const notes = await db.select().from(Notes).where(eq(Notes.userId, userId)).all();
  const threads = await db.select().from(Threads).where(eq(Threads.userId, userId)).all();
  const spaces = await db.select().from(Spaces).where(eq(Spaces.userId, userId)).all();
  const tags = await db.select().from(Tags).where(eq(Tags.userId, userId)).all();
  const userMetadata = await db.select().from(UserMetadata).where(eq(UserMetadata.userId, userId)).all();
  const userXP = await db.select().from(UserXP).where(eq(UserXP.userId, userId)).all();

  const noteIds = notes.map(n => n.id);
  const spaceIds = spaces.map(s => s.id);

  // Count junction table records
  let noteTagsCount = 0;
  let noteThreadsCount = 0;
  let commentsCount = 0;
  let scriptureMetadataCount = 0;
  let noteThreadAccessCount = 0;
  let membersCount = 0;

  for (const noteId of noteIds) {
    const nts = await db.select().from(NoteTags).where(eq(NoteTags.noteId, noteId)).all();
    noteTagsCount += nts.length;
    
    const ntrs = await db.select().from(NoteThreads).where(eq(NoteThreads.noteId, noteId)).all();
    noteThreadsCount += ntrs.length;
    
    const cmts = await db.select().from(Comments).where(eq(Comments.noteId, noteId)).all();
    commentsCount += cmts.length;
    
    try {
      const sm = await db.select().from(ScriptureMetadata).where(eq(ScriptureMetadata.noteId, noteId)).all();
      scriptureMetadataCount += sm.length;
    } catch (e) {
      // Skip if error
    }
    
    const nta = await db.select().from(NoteThreadAccess).where(eq(NoteThreadAccess.noteId, noteId)).all();
    noteThreadAccessCount += nta.length;
  }

  for (const spaceId of spaceIds) {
    const mems = await db.select().from(Members).where(eq(Members.spaceId, spaceId)).all();
    membersCount += mems.length;
  }

  return {
    notes: notes.length,
    threads: threads.length,
    spaces: spaces.length,
    tags: tags.length,
    noteTags: noteTagsCount,
    noteThreads: noteThreadsCount,
    comments: commentsCount,
    scriptureMetadata: scriptureMetadataCount,
    noteThreadAccess: noteThreadAccessCount,
    members: membersCount,
    userMetadata: userMetadata.length,
    userXP: userXP.length,
  };
}

async function runDeleteAccount(userId: string) {
  // 1. Fetch note IDs first (needed for junction table deletions)
  const userNotes = await db.select({ id: Notes.id }).from(Notes).where(eq(Notes.userId, userId)).all();
  const noteIds = userNotes.map(n => n.id);
  
  // Delete junction tables and related data
  if (noteIds.length > 0) {
    // Delete NoteThreads relationships
    for (const noteId of noteIds) {
      await db.delete(NoteThreads).where(eq(NoteThreads.noteId, noteId));
    }
    
    // Delete NoteTags relationships
    for (const noteId of noteIds) {
      await db.delete(NoteTags).where(eq(NoteTags.noteId, noteId));
    }
    
    // Delete Comments
    for (const noteId of noteIds) {
      await db.delete(Comments).where(eq(Comments.noteId, noteId));
    }
    
    // Delete ScriptureMetadata
    for (const noteId of noteIds) {
      await db.delete(ScriptureMetadata).where(eq(ScriptureMetadata.noteId, noteId));
    }
    
    // Delete NoteThreadAccess
    for (const noteId of noteIds) {
      await db.delete(NoteThreadAccess).where(eq(NoteThreadAccess.noteId, noteId));
    }
  }

  // 2. Delete Notes
  await db.delete(Notes).where(eq(Notes.userId, userId));

  // 3. Delete Threads
  await db.delete(Threads).where(eq(Threads.userId, userId));

  // 4. Delete Spaces and Members
  const userSpaces = await db.select({ id: Spaces.id }).from(Spaces).where(eq(Spaces.userId, userId)).all();
  const spaceIds = userSpaces.map(s => s.id);
  
  if (spaceIds.length > 0) {
    for (const spaceId of spaceIds) {
      await db.delete(Members).where(eq(Members.spaceId, spaceId));
    }
  }
  
  await db.delete(Spaces).where(eq(Spaces.userId, userId));

  // 5. Delete Tags (user's tags)
  await db.delete(Tags).where(eq(Tags.userId, userId));

  // 6. Delete UserXP
  await db.delete(UserXP).where(eq(UserXP.userId, userId));

  // 7. Delete UserMetadata
  await db.delete(UserMetadata).where(eq(UserMetadata.userId, userId));
}

