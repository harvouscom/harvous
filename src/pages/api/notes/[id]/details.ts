import type { APIRoute } from 'astro';
import { db, Notes, Threads, Comments, Tags, NoteTags, NoteThreads, eq, and, count } from 'astro:db';

export const GET: APIRoute = async ({ params, locals }) => {
  try {
    const { userId } = locals.auth();
    
    if (!userId) {
      return new Response(JSON.stringify({ error: 'Authentication required' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const noteId = params.id;

    if (!noteId) {
      return new Response(JSON.stringify({ error: 'Note ID is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    console.log("Fetching note details for ID:", noteId, "for user:", userId);

    // First, verify the note belongs to the user
    const note = await db.select()
      .from(Notes)
      .where(and(eq(Notes.id, noteId), eq(Notes.userId, userId)))
      .get();

    if (!note) {
      return new Response(JSON.stringify({ error: 'Note not found or access denied' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Get the primary thread that contains this note with note count
    const primaryThreadResult = await db
      .select({
        id: Threads.id,
        title: Threads.title,
        subtitle: Threads.subtitle,
        color: Threads.color,
        isPublic: Threads.isPublic,
        isPinned: Threads.isPinned,
        createdAt: Threads.createdAt,
        updatedAt: Threads.updatedAt,
        noteCount: count(Notes.id)
      })
      .from(Threads)
      .leftJoin(Notes, and(eq(Notes.threadId, Threads.id), eq(Notes.userId, userId)))
      .where(and(eq(Threads.id, note.threadId), eq(Threads.userId, userId)))
      .groupBy(Threads.id)
      .get();

    const primaryThread = primaryThreadResult;

    // Helper function to format relative time (same as original)
    function formatRelativeTime(date: Date): string {
      const now = new Date();
      const diffInMs = now.getTime() - date.getTime();
      const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
      const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));
      const diffInMinutes = Math.floor(diffInMs / (1000 * 60));

      if (diffInDays > 0) {
        return diffInDays === 1 ? "1 day ago" : `${diffInDays} days ago`;
      } else if (diffInHours > 0) {
        return diffInHours === 1 ? "1 hour ago" : `${diffInHours} hours ago`;
      } else if (diffInMinutes > 0) {
        return diffInMinutes === 1 ? "1 minute ago" : `${diffInMinutes} minutes ago`;
      } else {
        return "Just now";
      }
    }

    // Get the thread that contains this note (one-to-one relationship)
    // Format it to match the original CardThread.astro format
    const allThreads = primaryThread ? [{
      id: primaryThread.id,
      title: primaryThread.title,
      subtitle: `${primaryThread.noteCount || 0} notes`, // Add note count if available
      count: primaryThread.noteCount || 0,
      accentColor: `var(--color-${primaryThread.color || 'blessed-blue'})`, // Format color correctly
      lastUpdated: formatRelativeTime(new Date(primaryThread.updatedAt || primaryThread.createdAt)),
      createdAt: primaryThread.createdAt,
      isPrivate: !primaryThread.isPublic
    }] : [];

    // Get all comments for this note
    const comments = await db.select({
      id: Comments.id,
      content: Comments.content,
      createdAt: Comments.createdAt,
      updatedAt: Comments.updatedAt
    })
    .from(Comments)
    .where(and(eq(Comments.noteId, noteId), eq(Comments.userId, userId)))
    .orderBy(Comments.createdAt);

    // Get all tags for this note
    const noteTags = await db
      .select({
        id: Tags.id,
        name: Tags.name,
        color: Tags.color,
        category: Tags.category,
        isSystem: Tags.isSystem,
        isAutoGenerated: NoteTags.isAutoGenerated,
        confidence: NoteTags.confidence
      })
      .from(NoteTags)
      .innerJoin(Tags, eq(NoteTags.tagId, Tags.id))
      .where(and(eq(NoteTags.noteId, noteId), eq(Tags.userId, userId)))
      .orderBy(Tags.name);

    // Format the response
    const response = {
      success: true,
      note: {
        id: note.id,
        title: note.title,
        content: note.content,
        threadId: note.threadId,
        spaceId: note.spaceId,
        simpleNoteId: note.simpleNoteId,
        isPublic: note.isPublic,
        isFeatured: note.isFeatured,
        createdAt: note.createdAt,
        updatedAt: note.updatedAt
      },
      // Return both primary thread and all threads
      primaryThread: primaryThread ? {
        id: primaryThread.id,
        title: primaryThread.title,
        subtitle: primaryThread.subtitle,
        color: primaryThread.color,
        isPublic: primaryThread.isPublic,
        isPinned: primaryThread.isPinned,
        createdAt: primaryThread.createdAt,
        updatedAt: primaryThread.updatedAt
      } : null,
      threads: allThreads,
      comments: comments.map(comment => ({
        id: comment.id,
        content: comment.content,
        createdAt: comment.createdAt,
        updatedAt: comment.updatedAt
      })),
      tags: noteTags.map(tag => ({
        id: tag.id,
        name: tag.name,
        color: tag.color,
        category: tag.category,
        isSystem: tag.isSystem,
        isAutoGenerated: tag.isAutoGenerated,
        confidence: tag.confidence
      }))
    };

    console.log("Note details fetched successfully:", {
      noteId,
      primaryThreadCount: primaryThread ? 1 : 0,
      allThreadsCount: allThreads.length,
      commentCount: comments.length,
      tagCount: noteTags.length,
      primaryThread: primaryThread ? { id: primaryThread.id, title: primaryThread.title } : null,
      allThreads: allThreads.map(t => ({ id: t.id, title: t.title }))
    });

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error: any) {
    console.error('Error fetching note details:', error);
    return new Response(JSON.stringify({ 
      error: error.message || 'Failed to fetch note details' 
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
};
