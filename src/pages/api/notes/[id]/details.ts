import type { APIRoute } from 'astro';
import { db, Notes, Threads, Comments, Tags, NoteTags, eq, and } from 'astro:db';

export const GET: APIRoute = async ({ params, locals }) => {
  try {
    const { userId } = locals.auth();
    
    if (!userId) {
      return new Response(JSON.stringify({ error: 'Authentication required' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const noteId = params.id;

    if (!noteId) {
      return new Response(JSON.stringify({ error: 'Note ID is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    console.log("Fetching note details for ID:", noteId, "for user:", userId);

    // First, verify the note belongs to the user
    const note = await db.select()
      .from(Notes)
      .where(and(eq(Notes.id, noteId), eq(Notes.userId, userId)))
      .get();

    if (!note) {
      return new Response(JSON.stringify({ error: 'Note not found or access denied' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    // Get the thread that contains this note
    const thread = await db.select()
      .from(Threads)
      .where(and(eq(Threads.id, note.threadId), eq(Threads.userId, userId)))
      .get();

    // Get all comments for this note
    const comments = await db.select({
      id: Comments.id,
      content: Comments.content,
      createdAt: Comments.createdAt,
      updatedAt: Comments.updatedAt
    })
    .from(Comments)
    .where(and(eq(Comments.noteId, noteId), eq(Comments.userId, userId)))
    .orderBy(Comments.createdAt);

    // Get all tags for this note
    const noteTags = await db
      .select({
        id: Tags.id,
        name: Tags.name,
        color: Tags.color,
        category: Tags.category,
        isSystem: Tags.isSystem,
        isAutoGenerated: NoteTags.isAutoGenerated,
        confidence: NoteTags.confidence
      })
      .from(NoteTags)
      .innerJoin(Tags, eq(NoteTags.tagId, Tags.id))
      .where(and(eq(NoteTags.noteId, noteId), eq(Tags.userId, userId)))
      .orderBy(Tags.name);

    // Format the response
    const response = {
      success: true,
      note: {
        id: note.id,
        title: note.title,
        content: note.content,
        threadId: note.threadId,
        spaceId: note.spaceId,
        simpleNoteId: note.simpleNoteId,
        isPublic: note.isPublic,
        isFeatured: note.isFeatured,
        createdAt: note.createdAt,
        updatedAt: note.updatedAt
      },
      thread: thread ? {
        id: thread.id,
        title: thread.title,
        subtitle: thread.subtitle,
        color: thread.color,
        isPublic: thread.isPublic,
        isPinned: thread.isPinned,
        createdAt: thread.createdAt,
        updatedAt: thread.updatedAt
      } : null,
      comments: comments.map(comment => ({
        id: comment.id,
        content: comment.content,
        createdAt: comment.createdAt,
        updatedAt: comment.updatedAt
      })),
      tags: noteTags.map(tag => ({
        id: tag.id,
        name: tag.name,
        color: tag.color,
        category: tag.category,
        isSystem: tag.isSystem,
        isAutoGenerated: tag.isAutoGenerated,
        confidence: tag.confidence
      }))
    };

    console.log("Note details fetched successfully:", {
      noteId,
      threadCount: thread ? 1 : 0,
      commentCount: comments.length,
      tagCount: noteTags.length
    });

    return new Response(JSON.stringify(response), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error: any) {
    console.error('Error fetching note details:', error);
    return new Response(JSON.stringify({ 
      error: error.message || 'Failed to fetch note details' 
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
};
