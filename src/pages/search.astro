---
import Layout from "@/layouts/Layout.astro";
import CardStack from "@/components/CardStack.astro";
import SearchInput from "@/components/SearchInput.astro";
import TabNav from "@/components/TabNav.astro";
import CardNote from "@/components/CardNote.astro";
import CardThread from "@/components/CardThread.astro";
import PersistentNavigation from "@/components/PersistentNavigation.astro";
import SpaceButton from "@/components/SpaceButton.astro";
import SquareButton from "@/components/SquareButton.astro";
import Avatar from "@/components/Avatar.astro";
import MobileNavigation from "@/components/MobileNavigation.astro";
import MobileAdditional from "@/components/MobileAdditional.astro";
import { db, Notes, Threads, Tags, NoteTags, eq, and, or, like, desc, count } from "astro:db";
import { getThreadColorCSS } from "@/utils/colors";

// Helper function to strip HTML tags and decode entities
function stripHtml(html: string): string {
  if (!html) return '';
  
  // More aggressive HTML stripping
  let text = html
    // Remove script and style tags completely (including their content)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove all HTML tags (including those with complex attributes)
    .replace(/<[^>]*>/g, '')
    // Decode HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    .replace(/&#x60;/g, '`')
    .replace(/&#x3D;/g, '=')
    // Clean up whitespace
    .replace(/\s+/g, ' ')
    .trim();
    
  return text;
}

// Helper function to format relative time (same as dashboard)
function formatRelativeTime(date: Date): string {
  const now = new Date();
  const diffInMs = now.getTime() - date.getTime();
  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
  const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));
  const diffInMinutes = Math.floor(diffInMs / (1000 * 60));

  if (diffInDays > 0) {
    return diffInDays === 1 ? "1 day ago" : `${diffInDays} days ago`;
  } else if (diffInHours > 0) {
    return diffInHours === 1 ? "1 hour ago" : `${diffInHours} hours ago`;
  } else if (diffInMinutes > 0) {
    return diffInMinutes === 1 ? "1 minute ago" : `${diffInMinutes} minutes ago`;
  } else {
    return "Just now";
  }
}

// Get user data from Clerk authentication
const auth = Astro.locals.auth();
const { userId } = auth;

if (!userId) {
  return Astro.redirect('/sign-in');
}

// Try to fetch user data from Clerk API using secret key
let userData: any = null;
try {
  const clerkSecretKey = import.meta.env.CLERK_SECRET_KEY;
  if (clerkSecretKey) {
    const response = await fetch(`https://api.clerk.com/v1/users/${userId}`, {
      headers: {
        'Authorization': `Bearer ${clerkSecretKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (response.ok) {
      userData = await response.json();
    }
  }
} catch (error) {
  console.log('Error fetching user data:', error);
}

// Extract user data from API response or use fallbacks
const firstName = userData?.first_name || userData?.firstName || '';
const lastName = userData?.last_name || userData?.lastName || '';
const initials = `${firstName.charAt(0) || ''}${lastName.charAt(0) || ''}`.toUpperCase() || 'U';

// Get user color from database
let userColor = 'paper'; // default
try {
  const { UserMetadata } = await import('astro:db');
  const userMetadata = await db.select().from(UserMetadata).where(eq(UserMetadata.userId, userId)).get();
  userColor = userMetadata?.userColor || 'paper';
} catch (error) {
  console.log('Error fetching user color:', error);
}

// Get search query from URL parameters
const url = new URL(Astro.request.url);
const query = url.searchParams.get('q') || '';
const activeTab = url.searchParams.get('tab') || 'all';

// Search results
let searchResults: any[] = [];
let notesResults: any[] = [];
let threadsResults: any[] = [];

// Perform search if query exists
if (query.trim()) {
  try {
    const searchTerm = `%${query.trim()}%`;
    const searchTermLower = `%${query.trim().toLowerCase()}%`;
    
    // Enhanced search with multiple patterns for better matching
    const searchPatterns = [
      searchTerm,           // exact case match
      searchTermLower,     // lowercase match
      `%${query.trim().split(' ').join('%')}%`, // word boundary match
    ];
    
    // Search notes with enhanced matching (including tags)
    // First, get notes that match title/content
    const notesByContent = await db
      .select({
        id: Notes.id,
        title: Notes.title,
        content: Notes.content,
        threadId: Notes.threadId,
        spaceId: Notes.spaceId,
        simpleNoteId: Notes.simpleNoteId,
        createdAt: Notes.createdAt,
        updatedAt: Notes.updatedAt,
        userId: Notes.userId,
        isPublic: Notes.isPublic,
        isFeatured: Notes.isFeatured,
        order: Notes.order
      })
      .from(Notes)
      .where(
        and(
          eq(Notes.userId, userId),
          or(
            like(Notes.title, searchPatterns[0]),
            like(Notes.content, searchPatterns[0]),
            like(Notes.title, searchPatterns[1]),
            like(Notes.content, searchPatterns[1]),
            like(Notes.title, searchPatterns[2]),
            like(Notes.content, searchPatterns[2])
          )
        )
      )
      .orderBy(desc(Notes.updatedAt), desc(Notes.createdAt));

    // Then, get notes that match tags (without duplicates)
    const notesByTags = await db
      .select({
        id: Notes.id,
        title: Notes.title,
        content: Notes.content,
        threadId: Notes.threadId,
        spaceId: Notes.spaceId,
        simpleNoteId: Notes.simpleNoteId,
        createdAt: Notes.createdAt,
        updatedAt: Notes.updatedAt,
        userId: Notes.userId,
        isPublic: Notes.isPublic,
        isFeatured: Notes.isFeatured,
        order: Notes.order
      })
      .from(Notes)
      .innerJoin(NoteTags, eq(Notes.id, NoteTags.noteId))
      .innerJoin(Tags, eq(NoteTags.tagId, Tags.id))
      .where(
        and(
          eq(Notes.userId, userId),
          or(
            like(Tags.name, searchPatterns[0]),
            like(Tags.name, searchPatterns[1]),
            like(Tags.name, searchPatterns[2])
          )
        )
      )
      .orderBy(desc(Notes.updatedAt), desc(Notes.createdAt));

    // Combine and deduplicate results
    const allNotes = [...notesByContent, ...notesByTags];
    const uniqueNotes = allNotes.filter((note, index, self) => 
      index === self.findIndex(n => n.id === note.id)
    );
    
    // Sort by date
    const notes = uniqueNotes.sort((a, b) => 
      new Date(b.updatedAt || b.createdAt).getTime() - new Date(a.updatedAt || a.createdAt).getTime()
    );

    // Search threads with enhanced matching
    const threads = await db
      .select()
      .from(Threads)
      .where(
        and(
          eq(Threads.userId, userId),
          or(
            like(Threads.title, searchPatterns[0]),
            like(Threads.title, searchPatterns[1]),
            like(Threads.title, searchPatterns[2])
          )
        )
      )
      .orderBy(desc(Threads.updatedAt), desc(Threads.createdAt));

    // Helper function to calculate relevance score
    function calculateRelevanceScore(item: any, query: string): number {
      const queryLower = query.toLowerCase();
      const titleLower = (item.title || '').toLowerCase();
      const contentLower = (item.content || '').toLowerCase();
      const tagsLower = (item.tags || []).map((tag: any) => tag.name.toLowerCase()).join(' ');
      
      let score = 0;
      
      // Title matches get highest score
      if (titleLower.includes(queryLower)) {
        score += 100;
        // Exact title match gets bonus
        if (titleLower === queryLower) score += 50;
        // Title starts with query gets bonus
        if (titleLower.startsWith(queryLower)) score += 25;
      }
      
      // Content matches get medium score
      if (contentLower.includes(queryLower)) {
        score += 50;
        // Multiple occurrences in content get bonus
        const occurrences = (contentLower.match(new RegExp(queryLower, 'g')) || []).length;
        score += occurrences * 10;
      }
      
      // Tag matches get high score (between title and content)
      if (tagsLower.includes(queryLower)) {
        score += 75;
        // Multiple tag matches get bonus
        const tagOccurrences = (tagsLower.match(new RegExp(queryLower, 'g')) || []).length;
        score += tagOccurrences * 15;
      }
      
      // Recent content gets slight boost
      const daysSinceUpdate = Math.floor((Date.now() - new Date(item.updatedAt || item.createdAt).getTime()) / (1000 * 60 * 60 * 24));
      if (daysSinceUpdate < 7) score += 10;
      if (daysSinceUpdate < 30) score += 5;
      
      return score;
    }

    // Get tags for each note
    const notesWithTags = await Promise.all(
      notes.map(async (note) => {
        try {
          const noteTags = await db
            .select({
              id: Tags.id,
              name: Tags.name,
              color: Tags.color,
              category: Tags.category
            })
            .from(NoteTags)
            .innerJoin(Tags, eq(NoteTags.tagId, Tags.id))
            .where(and(eq(NoteTags.noteId, note.id), eq(Tags.userId, userId)));

          return { ...note, tags: noteTags };
        } catch (error) {
          console.log('Error fetching tags for note:', error);
          return { ...note, tags: [] };
        }
      })
    );

    // Format notes results with relevance scoring
    notesResults = notesWithTags.map(note => {
      const cleanContent = stripHtml(note.content);
      const noteData: any = {
        id: `note-${note.id}`,
        type: "note" as const,
        title: note.title || "Untitled Note",
        content: cleanContent,
        noteId: note.id,
        threadId: note.threadId,
        spaceId: note.spaceId,
        lastUpdated: note.updatedAt || note.createdAt,
        updatedAt: note.updatedAt || note.createdAt,
        tags: note.tags
      };
      
      // Calculate relevance score
      noteData.relevanceScore = calculateRelevanceScore(noteData, query.trim());
      
      // Truncate content for display
      noteData.content = cleanContent.substring(0, 150) + (cleanContent.length > 150 ? "..." : "");
      
      return noteData;
    });

    // Get note counts for threads
    const threadNoteCounts = await Promise.all(
      threads.map(async (thread) => {
        const noteCount = await db
          .select({ count: count() })
          .from(Notes)
          .where(and(eq(Notes.userId, userId), eq(Notes.threadId, thread.id)));
        return { threadId: thread.id, count: noteCount[0]?.count || 0 };
      })
    );

    // Format threads results with relevance scoring
    threadsResults = threads.map(thread => {
      const noteCountData = threadNoteCounts.find(tc => tc.threadId === thread.id);
      const noteCount = noteCountData?.count || 0;
      const threadData: any = {
        id: `thread-${thread.id}`,
        type: "thread" as const,
        title: thread.title,
        subtitle: `${noteCount} notes`,
        count: noteCount,
        threadId: thread.id,
        spaceId: thread.spaceId,
        lastUpdated: formatRelativeTime(thread.updatedAt || thread.createdAt),
        updatedAt: thread.updatedAt || thread.createdAt,
        accentColor: getThreadColorCSS(thread.color),
      };
      
      // Calculate relevance score for threads
      threadData.relevanceScore = calculateRelevanceScore(threadData, query.trim());
      
      return threadData;
    });

    // Combine all results and sort by relevance score first, then by date
    searchResults = [...notesResults, ...threadsResults].sort((a, b) => {
      // First sort by relevance score (higher is better)
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // Then by date (newer is better)
      return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
    });

  } catch (error) {
    console.error("Error performing search:", error);
    searchResults = [];
    notesResults = [];
    threadsResults = [];
  }
}

// Note: Tab filtering is now handled by the TabNav component with data-tab-content attributes
---

<Layout title="Search - Harvous" contentType="dashboard" currentThread={null} currentSpace={null}>
  <!-- Navigation Column -->
  <div slot="navigation" class="h-full">
    <div class="flex flex-col items-start justify-between relative h-full">
      <!-- Top Section - Navigation -->
      <div class="flex flex-col gap-12 items-start justify-start w-full flex-1 min-h-0">
        <!-- Navigation Buttons -->
        <div class="flex flex-col items-start justify-start w-full">
          <a href="/dashboard" class="w-full">
            <SpaceButton text="For You" count={0} state="WithCount" className="w-full" isActive={false} />
          </a>
          
          {/* Persistent Navigation - shows recently accessed items */}
          <PersistentNavigation />
        </div>
      </div>
      
      <!-- Bottom Section with New Space Button, Search, and Avatar -->
      <div class="flex gap-3 items-center justify-start w-full shrink-0">
        <a href="/new-space" class="flex-1">
          <SpaceButton text="New Space" className="w-full" />
        </a>
        <SquareButton variant="Search" />
        <a href="/profile">
          <Avatar initials={initials} color={userColor} />
        </a>
      </div>
    </div>
  </div>

  <!-- Main Column -->
  <div slot="main" class="h-full">
    <div class="flex flex-col h-full">
      <CardStack title="Search" headerBgColor="var(--color-paper)">
        <div class="flex flex-col gap-6">
          <!-- Search Input -->
          <div class="w-full" x-data="{ 
              searchQuery: '', 
              suggestions: [], 
              showSuggestions: false,
              selectedSuggestion: -1
            }" x-init="
              const updateSearchQuery = () => {
                const urlParams = new URLSearchParams(window.location.search);
                searchQuery = urlParams.get('q') || '';
                suggestions = [];
                showSuggestions = false;
              };
              updateSearchQuery();
              
              // Listen for URL changes (for View Transitions)
              window.addEventListener('popstate', updateSearchQuery);
              document.addEventListener('astro:page-load', updateSearchQuery);
              
              // Global function for search suggestions
              window.fetchSearchSuggestions = async (query) => {
                if (query.length < 2) return;
                try {
                  const response = await fetch(`/api/search?q=${encodeURIComponent(query)}&type=all&limit=5`);
                  const data = await response.json();
                  suggestions = data.results || [];
                  showSuggestions = true;
                } catch (error) {
                  console.error('Search suggestions error:', error);
                  suggestions = [];
                }
              };
            ">
            <form method="GET" action="/search" class="w-full relative" x-on:submit="
              if (!searchQuery.trim()) { 
                $event.preventDefault(); 
              } else {
                // Save to recent searches - count will be updated after search results load
                const recentSearches = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
                const searchTerm = searchQuery.trim();
                const newSearchItem = { term: searchTerm, count: 0 };
                const filteredSearches = recentSearches.filter(s => s.term !== searchTerm);
                const newSearches = [newSearchItem, ...filteredSearches];
                localStorage.setItem('harvous-recent-searches', JSON.stringify(newSearches.slice(0, 10)));
              }
            ">
              <div class="w-full search-input rounded-3xl grid items-center grid-cols-[auto_1fr_auto] py-5 px-4 gap-3 min-h-[64px]">
                <svg width="20" height="20" class="fill-[var(--color-pebble-grey)]" viewBox="0 0 512 512">
                  <path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/>
                </svg>
                <input 
                  type="text" 
                  name="q"
                  x-model="searchQuery"
                  role="searchbox"
                  aria-label="Search"
                  class="outline-none bg-transparent text-subtitle text-[var(--color-deep-grey)] placeholder:text-[var(--color-pebble-grey)]" 
                  placeholder="Search notes and threads..."
                  x-on:input="
                    if (searchQuery.length >= 2) {
                      // Show search suggestions
                      fetchSearchSuggestions(searchQuery);
                    } else {
                      suggestions = [];
                    }
                  "
                />
                <svg 
                  x-show="Boolean(searchQuery)" 
                  x-cloak
                  x-on:click="searchQuery = ''; window.location.href = '/search';"
                  role="button"
                  aria-label="Clear search"
                  width="20" 
                  height="20"
                  class="fill-[var(--color-deep-grey)] cursor-pointer" 
                  viewBox="0 0 384 512"
                >
                  <path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/>
                </svg>
              </div>
              
              <!-- Search Suggestions Dropdown -->
              <div 
                x-show="showSuggestions && suggestions.length > 0" 
                x-cloak
                class="absolute top-full left-0 right-0 mt-2 bg-white border border-[var(--color-pebble-grey)] rounded-lg shadow-lg z-50 max-h-60 overflow-y-auto"
              >
                <template x-for="(suggestion, index) in suggestions" :key="suggestion.id">
                  <div 
                    class="px-4 py-3 hover:bg-[var(--color-paper)] cursor-pointer border-b border-[var(--color-pebble-grey)] last:border-b-0"
                    :class="{ 'bg-[var(--color-paper)]': selectedSuggestion === index }"
                    x-on:click="
                      searchQuery = suggestion.title;
                      showSuggestions = false;
                      window.location.href = '/search?q=' + encodeURIComponent(suggestion.title);
                    "
                    x-on:mouseenter="selectedSuggestion = index"
                  >
                    <div class="flex items-center gap-3">
                      <div class="w-2 h-2 rounded-full" :class="suggestion.type === 'note' ? 'bg-blue-500' : 'bg-green-500'"></div>
                      <div class="flex-1 min-w-0">
                        <div class="font-medium text-[var(--color-deep-grey)] truncate" x-text="suggestion.title"></div>
                        <div class="text-sm text-[var(--color-pebble-grey)] truncate" x-text="suggestion.content || suggestion.subtitle"></div>
                      </div>
                    </div>
                  </div>
                </template>
              </div>
            </form>
          </div>

          <!-- Tab Navigation -->
          {query && (
            <div class="flex flex-col gap-3">
              <TabNav 
                tabs={[
                  { 
                    id: "all", 
                    label: "All", 
                    isActive: activeTab === 'all' 
                  },
                  { 
                    id: "notes", 
                    label: "Notes", 
                    isActive: activeTab === 'notes' 
                  },
                  { 
                    id: "threads", 
                    label: "Threads", 
                    isActive: activeTab === 'threads' 
                  }
                ]}
                class="search-tabs"
              />
              
              <!-- All Content -->
              <div class="search-results flex flex-col" data-tab-content="all">
                {searchResults.length > 0 ? (
                  searchResults.map(item => (
                    <div class={`content-item ${item.type}-item mb-3`}>
                      <a 
                        href={item.type === 'thread' ? `/${item.threadId}` : `/${item.noteId}`}
                        class="block transition-transform duration-200 hover:scale-[1.002]"
                      >
                        {item.type === 'note' ? (
                          <CardNote 
                            title={item.title}
                            content={item.content}
                          />
                        ) : (
                          <CardThread 
                            title={item.title}
                            subtitle={item.subtitle}
                            count={item.count}
                            accentColor={item.accentColor}
                            lastUpdated={item.lastUpdated}
                          />
                        )}
                      </a>
                    </div>
                  ))
                ) : (
                  <div class="flex flex-col items-center justify-center min-h-[300px] w-full text-center">
                    <div class="flex flex-col gap-2 items-center justify-center">
                      <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                        <p>No results found</p>
                      </div>
                      <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                        <p>Try searching for different keywords or check your spelling.</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              <!-- Notes Only Content -->
              <div class="search-results flex flex-col hidden" data-tab-content="notes">
                {notesResults.length > 0 ? (
                  notesResults.map(item => (
                    <div class={`content-item ${item.type}-item mb-3`}>
                      <a 
                        href={`/${item.noteId}`}
                        class="block transition-transform duration-200 hover:scale-[1.002]"
                      >
                        <CardNote 
                          title={item.title}
                          content={item.content}
                        />
                      </a>
                    </div>
                  ))
                ) : (
                  <div class="flex flex-col items-center justify-center min-h-[300px] w-full text-center">
                    <div class="flex flex-col gap-2 items-center justify-center">
                      <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                        <p>No notes found</p>
                      </div>
                      <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                        <p>Try searching for different keywords or check your spelling.</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              <!-- Threads Only Content -->
              <div class="search-results flex flex-col hidden" data-tab-content="threads">
                {threadsResults.length > 0 ? (
                  threadsResults.map(item => (
                    <div class={`content-item ${item.type}-item mb-3`}>
                      <a 
                        href={`/${item.threadId}`}
                        class="block transition-transform duration-200 hover:scale-[1.002]"
                      >
                        <CardThread 
                          title={item.title}
                          subtitle={item.subtitle}
                          count={item.count}
                          accentColor={item.accentColor}
                          lastUpdated={item.lastUpdated}
                        />
                      </a>
                    </div>
                  ))
                ) : (
                  <div class="flex flex-col items-center justify-center min-h-[300px] w-full text-center">
                    <div class="flex flex-col gap-2 items-center justify-center">
                      <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                        <p>No threads found</p>
                      </div>
                      <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                        <p>Try searching for different keywords or check your spelling.</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}

          <!-- Empty State (no search query) -->
          {!query && (
            <div class="flex flex-col gap-6">

              <!-- Recent Searches -->
              <div class="flex flex-col gap-3" x-data="{ recentSearches: [] }" x-init="
                const updateRecentSearches = () => {
                  const stored = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
                  // Handle both old format (strings) and new format (objects)
                  recentSearches = stored.map(item => {
                    if (typeof item === 'string') {
                      return { term: item, count: 0 };
                    }
                    return item;
                  }).slice(0, 5);
                };
                updateRecentSearches();
                
                // Listen for updates when items are removed or counts are updated
                window.addEventListener('recent-searches-updated', updateRecentSearches);
              ">
                <div x-show="recentSearches.length > 0" class="flex flex-col gap-3">
                  <div class="font-sans font-semibold text-[#4a473d] text-[16px] leading-[1.2]">
                    <p>Recent searches</p>
                  </div>
                  <div class="flex flex-col gap-2">
                    <template x-for="search in recentSearches" :key="search.term">
                      <div class="recent-search-item">
                        <div class="relative nav-item-container">
                          <a :href="`/search?q=${encodeURIComponent(search.term)}`" class="block">
                            <button class="space-button relative rounded-xl h-[64px] cursor-pointer transition-[scale,shadow] duration-300 pl-4 pr-0 group w-full" style="background-image: var(--color-gradient-gray); box-shadow: 0px -3px 0px 0px rgba(120, 118, 111, 0.2) inset;">
                              <div class="flex items-center justify-between relative w-full h-full pl-2 pr-0 transition-transform duration-125">
                                <span class="text-[var(--color-deep-grey)] font-sans text-[18px] font-semibold whitespace-nowrap" x-text="search.term"></span>
                                <div class="flex items-center justify-center p-[20px]">
                                  <div class="badge-count bg-[rgba(120,118,111,0.1)] flex items-center justify-center rounded-3xl w-6 h-6">
                                    <span class="text-[14px] font-sans font-semibold text-[var(--color-deep-grey)] leading-[0]" x-text="search.count"></span>
                                  </div>
                                </div>
                              </div>
                            </button>
                          </a>
                          <div onclick="handleCloseClick(event, this)" class="close-icon absolute top-1/2 right-5 transform -translate-y-1/2 flex items-center justify-center w-6 h-6 cursor-pointer" :data-item-id="search.term">
                            <svg class="w-4 h-4 fill-current" style="color: var(--color-deep-grey);" viewBox="0 0 384 512">
                              <path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/>
                            </svg>
                          </div>
                        </div>
                      </div>
                    </template>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </CardStack>
    </div>
  </div>

  <!-- Mobile Navigation -->
  <div slot="mobile-navigation">
    <MobileNavigation 
      spaces={[]}
      threads={[]}
      inboxCount={0}
      currentSpace={null}
      currentThread={null}
      initials={initials}
    />
  </div>

  <!-- Mobile Additional -->
  <div slot="mobile-additional">
    <MobileAdditional contentType="dashboard" currentSpace={null} />
  </div>
</Layout>

<style>
  .search-input {
    background: var(--color-gradient-gray);
    box-shadow: var(--shadow-small);
  }
  
  .space-button {
    will-change: transform;
    transition: box-shadow 0.125s ease-in-out;
  }

  .space-button:active {
    filter: brightness(0.97);
    box-shadow: 
      0px -1px 0px 0px rgba(120, 118, 111, 0.2) inset,
      0px 1px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:active > div {
    translate: 0 0;
    transform: scale(0.98);
  }

  /* Close icon hover states for recent searches */
  .nav-item-container:hover .badge-count {
    display: none !important;
  }
  .nav-item-container:hover .close-icon {
    display: flex !important;
  }
  .close-icon {
    display: none;
  }
</style>

<script>
  // Handle tab navigation with URL updates
  document.addEventListener('DOMContentLoaded', () => {
    const tabButtons = document.querySelectorAll('.search-tabs [data-tab-button]');
    
    tabButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        e.preventDefault();
        const tabId = button.getAttribute('data-tab-id');
        if (tabId) {
          const url = new URL(window.location.href);
          url.searchParams.set('tab', tabId);
          window.location.href = url.toString();
        }
      });
    });
  });

  // Function to remove a search term from recent searches
  function removeFromRecentSearches(searchTerm: string) {
    const recentSearches = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
    const updatedSearches = recentSearches.filter((search: any) => {
      // Handle both old format (strings) and new format (objects)
      const term = typeof search === 'string' ? search : search.term;
      return term !== searchTerm;
    });
    localStorage.setItem('harvous-recent-searches', JSON.stringify(updatedSearches));
    
    // Trigger Alpine.js reactivity by dispatching a custom event
    window.dispatchEvent(new CustomEvent('recent-searches-updated'));
  }

  // Make function globally available
  (window as any).removeFromRecentSearches = removeFromRecentSearches;

  // Update result count for current search
  function updateCurrentSearchCount() {
    const urlParams = new URLSearchParams(window.location.search);
    const currentQuery = urlParams.get('q');
    
    if (currentQuery) {
      // Only count visible results from the "All" tab (which is the default active tab)
      const allTabResults = document.querySelector('[data-tab-content="all"]');
      let resultCount = 0;
      
      if (allTabResults) {
        // Count all content items in the "All" tab (it's the default visible tab)
        const visibleResults = allTabResults.querySelectorAll('.content-item');
        resultCount = visibleResults.length;
      } else {
        // Fallback: count all visible content items
        const allVisibleResults = document.querySelectorAll('.content-item');
        resultCount = allVisibleResults.length;
      }
      
      const recentSearches = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
      const updatedSearches = recentSearches.map((search: any) => {
        if (search.term === currentQuery) {
          return { ...search, count: resultCount };
        }
        return search;
      });
      localStorage.setItem('harvous-recent-searches', JSON.stringify(updatedSearches));
      
      // Trigger Alpine.js reactivity
      window.dispatchEvent(new CustomEvent('recent-searches-updated'));
    }
  }

  // Run after page loads and also after View Transitions
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateCurrentSearchCount, 200); // Increased delay
    
    // Also use MutationObserver to watch for search results
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' && (mutation.target as Element).classList?.contains('search-results')) {
          setTimeout(updateCurrentSearchCount, 100);
        }
      });
    });
    
    // Observe the search results container
    const searchResultsContainer = document.querySelector('.search-results');
    if (searchResultsContainer) {
      observer.observe(searchResultsContainer, { childList: true, subtree: true });
    }
  });
  
  // Also run after View Transitions
  document.addEventListener('astro:page-load', () => {
    setTimeout(updateCurrentSearchCount, 200);
  });
</script>
