---
import { db, eq, Notes, and, NoteThreads, count, Threads } from "astro:db";
import { actions } from "astro:actions";
import { z } from "zod";
import Layout from "@/layouts/Layout.astro";
import IconButton from "@/components/IconButton.astro";
import BookmarkIcon from "@fortawesome/fontawesome-free/svgs/solid/bookmark.svg";
import XmarkIcon from "@fortawesome/fontawesome-free/svgs/solid/xmark.svg";
import DeleteIcon from "@fortawesome/fontawesome-free/svgs/solid/trash.svg";
import Tab from "@/components/TabBar/Tab.astro";
import ChonkButton from "@/components/ChonkButton.astro";
import PencilIcon from "@fortawesome/fontawesome-free/svgs/solid/pencil.svg";
import MetaBar from "@/components/MetaBar.astro";
import ThreadsDrawer from "@/components/ThreadsDrawer.astro";

const { id } = Astro.params;
// Get the threadId from query param if it exists
const threadId = Astro.url.searchParams.get('threadId');
let sourceThread = null;

// Validate ID parameter
if (!id || z.number({ coerce: true }).safeParse(id).success === false) {
  return Astro.redirect("/feed/notes");
}

const numericId = parseInt(id);
const currentUser = Astro.locals.auth();
const userId = currentUser ? currentUser.userId : null;

if (!userId) {
  return Astro.redirect("/login");
}

// Only fetch the note if we're not already redirecting
const notes = await db
  .select()
  .from(Notes)
  .where(and(eq(Notes.id, numericId), eq(Notes.userId, userId as string)))
  .limit(1);

if (!notes.length) {
  return Astro.redirect("/feed/notes");
}

// Fetch thread if we have a threadId
if (threadId && z.number({ coerce: true }).safeParse(threadId).success) {
  const threads = await db
    .select()
    .from(Threads)
    .where(and(eq(Threads.id, parseInt(threadId)), eq(Threads.userId, userId as string)))
    .limit(1);
  
  if (threads.length > 0) {
    sourceThread = threads[0];
  }
}

// Get thread count for this note
let threadCountValue = 0;
try {
  const threadCount = await db
    .select({ count: count() })
    .from(NoteThreads)
    .where(eq(NoteThreads.noteId, numericId));
  
  threadCountValue = threadCount[0]?.count || 0;
} catch (err) {
  console.error("Error fetching thread count:", err);
}

const noteData = notes[0];
---

<Layout title="Note">
  <div x-data="{ showActionBar: false }" class="flex flex-col min-h-[100vh] bg-[var(--color-soft-paper)]">
    <section class="bg-(--color-fog-white) pt-3">
      <div class="px-3 mx-auto max-w-screen-sm flex items-center">
        <div class="flex h-[48px]">
          <Tab label="Feed" href="/feed" />
          {sourceThread && (
            <Tab 
              label="Thread" 
              href={`/feed/threads/${sourceThread.id}`} 
              closable 
            />
          )}
          <Tab label="Note" active closable />
          <Tab label="Profile" href="/feed/profile" />
        </div>
      </div>
    </section>

    <main
      class="w-full max-w-screen-sm mx-auto px-3 pt-6 flex-grow flex flex-col gap-3"
    >
      <section class="w-full px-1 py-2 flex items-center gap-2 relative">
        <button 
          class="icon-btn rounded-full w-[44px] h-[44px] flex items-center justify-center shadow-[0px_-2.91px_0px_0px_#0000001A_inset]"
          :class="showActionBar ? 'bg-[var(--color-stone-grey)] text-[var(--color-light-paper)] fill-[var(--color-light-paper)]' : 'bg-[var(--color-paper)] text-[var(--color-stone-grey)] fill-[var(--color-stone-grey)]'"
          @click="showActionBar = !showActionBar"
        >
          <BookmarkIcon x-show="!showActionBar" class="w-[20px] h-[20px]" />
          <XmarkIcon x-cloak x-show="showActionBar" class="w-[20px] h-[20px]" />
        </button>
        <h1 class="text-title">{noteData.title || "Untitled Note"}</h1>
        
        <!-- Floating action bar positioned absolutely below the button -->
        <div 
          x-show="showActionBar" 
          x-cloak
          class="absolute top-[64px] left-[-12px] right-[-12px] z-10 bg-(--color-pebble-grey) p-3 rounded-xl shadow-lg"
        >
          <div class="grid grid-cols-2 gap-3 w-full">
            <a class="grid" href={`/feed/notes/${noteData.id}/edit`}>
              <ChonkButton text="Edit Note">
                <PencilIcon class="w-[15px] h-[15px] text-inherit fill-current" />
              </ChonkButton>
            </a>
            <form 
              id="deleteNoteForm"
              class="grid" 
              method="POST" 
              action={actions.notes.delete}
            >
              <input type="hidden" name="id" value={noteData.id} />
              <input type="hidden" name="userId" value={userId} />
              <button type="submit" style="width: 100%; height: 100%; padding: 0; background: none; border: none;">
                <ChonkButton text="Delete">
                  <DeleteIcon class="w-[15px] h-[15px] text-inherit fill-current" />
                </ChonkButton>
              </button>
            </form>
          </div>
        </div>
      </section>

      <section class="w-full !select-text whitespace-normal flex flex-col gap-5 px-3 py-5 bg-(--color-light-paper) rounded-xl trix-content flex-grow">
        <p class="text-caption text-(--color-stone-grey) w-fit">{noteData.createdAt.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}</p>
        <div set:html={noteData.content}></div>
      </section>
      
      <div class="w-full pb-[12px]">
        <MetaBar noteId={noteData.id} />
      </div>
    </main>
    
    <!-- Thread Drawer -->
    <ThreadsDrawer noteId={numericId} userId={userId as string} />
  </div>

<script define:vars={{ threadCountValue, noteId: numericId, sourceThreadId: sourceThread?.id }}>
  document.addEventListener('DOMContentLoaded', () => {
    // Store the current note ID to localStorage
    localStorage.setItem('lastViewedNote', noteId.toString());
    
    // Store the source thread ID if available
    if (sourceThreadId) {
      localStorage.setItem('sourceThreadForNote', sourceThreadId.toString());
    } else {
      // If no source thread but coming from thread page, maintain that context
      const lastViewedThread = localStorage.getItem('lastViewedThread');
      if (lastViewedThread) {
        localStorage.setItem('sourceThreadForNote', lastViewedThread);
      }
    }
    
    // Handle note deletion
    const deleteForm = document.getElementById('deleteNoteForm');
    if (deleteForm) {
      deleteForm.addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Clear note-related localStorage items before submitting
        localStorage.removeItem('lastViewedNote');
        
        // Create FormData and submit with fetch
        fetch(deleteForm.action, {
          method: 'POST',
          body: new FormData(deleteForm)
        })
        .then(response => response.json())
        .then(data => {
          console.log('Note deleted successfully:', data);
          
          // Check if we came from a thread view
          const sourceThread = localStorage.getItem('sourceThreadForNote');
          if (sourceThread) {
            // Redirect back to the thread view
            window.location.href = `/feed/threads/${sourceThread}`;
          } else {
            // Otherwise, redirect to dashboard
            window.location.href = '/feed';
          }
        })
        .catch(error => {
          console.error('Error deleting note:', error);
          // Redirect to dashboard on error
          window.location.href = '/feed';
        });
      });
    }
    
    // Update thread counter
    const updateThreadCounter = (count) => {
      const threadCounter = document.querySelector('[data-counter="threads"]');
      if (threadCounter) {
        threadCounter.textContent = count.toString();
      }
    };
    
    // Set initial count
    updateThreadCounter(threadCountValue);
    
    // Listen for thread changes
    window.addEventListener('thread-changed', (e) => {
      if (e.detail && typeof e.detail.count === 'number') {
        updateThreadCounter(e.detail.count);
      }
    });
  });
</script>
</Layout>