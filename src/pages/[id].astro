---
import Layout from "@/layouts/Layout.astro";
import CardStack from "@/components/CardStack.astro";
import CardFull from "@/components/CardFull.astro";
import CardFullEditableReact from "@/components/CardFullEditableReact.astro";
import SearchInput from "@/components/SearchInput.astro";
import SquareButton from "@/components/SquareButton.astro";
import Avatar from "@/components/Avatar.astro";
import TabNav from "@/components/TabNav.astro";
import CardNote from "@/components/CardNote.astro";
import CardThread from "@/components/CardThread.astro";
import NavigationColumnReact from "@/components/NavigationColumnReact.astro";
import { db, Threads, Notes, Spaces, NoteThreads, ScriptureMetadata, eq, and, desc, count, ne } from "astro:db";
import { getAllThreadsWithCounts, getSpacesWithCounts, getNotesForThread, getThreadsForSpace, getNotesForSpace, getInboxCount, getInboxDisplayCount } from "@/utils/dashboard-data";
import { getThreadColorCSS, getThreadGradientCSS } from "@/utils/colors";
// Sample data imports removed - using real database data only
import { detectActiveThreadFromPath } from "@/utils/navigation-state";

// Helper function to strip HTML tags and decode entities
function stripHtml(html: string): string {
  if (!html) return '';
  
  // More aggressive HTML stripping
  let text = html
    // Remove script and style tags completely (including their content)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove all HTML tags (including those with complex attributes)
    .replace(/<[^>]*>/g, '')
    // Decode HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    .replace(/&#x60;/g, '`')
    .replace(/&#x3D;/g, '=')
    // Clean up whitespace
    .replace(/\s+/g, ' ')
    .trim();
    
  return text;
}
import { ensureUnorganizedThread } from "@/utils/unorganized-thread";
import MobileNavigation from "@/components/MobileNavigation.astro";
import MobileAdditional from "@/components/MobileAdditional.astro";

// Dynamic routing - no static paths needed

// Get user data from Clerk authentication
const auth = Astro.locals.auth();
const { userId } = auth;

if (!userId) {
  return Astro.redirect('/sign-in');
}

// Get cached user data (optimized - no API calls on every page load)
import { getCachedUserData, type CachedUserData } from '@/utils/user-cache';

let userData: CachedUserData;
try {
  userData = await getCachedUserData(userId);
} catch (error) {
  console.log('Error getting cached user data:', error);
  // Fallback data
  userData = {
    firstName: '',
    lastName: '',
    email: '',
    initials: 'U',
    displayName: 'User',
    userColor: 'paper',
  };
}

const { firstName, lastName, initials, userColor } = userData;

const { id } = Astro.params;

// Determine if this is a thread, note, or space based on the ID prefix
const isThread = id?.startsWith('thread_');
const isNote = id?.startsWith('note_');
const isSpace = id?.startsWith('space_');

// Determine content type for context-aware More menu
let contentType: "thread" | "note" | "space" | "dashboard" = "dashboard";
if (isThread) contentType = "thread";
else if (isNote) contentType = "note";
else if (isSpace) contentType = "space";

let content: any = null;
let threads: any[] = [];
let spaces: any[] = [];
let pageTitle = "";
let pageContent = "";
let currentThread: any = null;
let currentSpace: any = null;
let threadNotes: any[] = [];
let inboxCount: number = 0;

// Database functions are imported at the top

  // Sample data code removed - always use real database
  /*
  if (false) {
    // Use robust sample data system
    if (isThread) {
      // Find thread in sample data
      const thread = [...SAMPLE_DATA.unorganizedThreads, ...SAMPLE_DATA.organizedThreads]
        .find(t => t.id === id);
      
      if (thread) {
        // Get notes for this thread from sample data
        threadNotes = SAMPLE_DATA.threadNotes.filter(note => note.threadId === thread.id);

        content = {
          id: thread.id,
          title: thread.title,
          subtitle: thread.content,
          color: thread.color,
          spaceId: thread.spaceId,
          notes: threadNotes,
          noteCount: threadNotes.length
        };
        currentThread = {
          id: thread.id,
          title: thread.title,
          color: thread.color,
          noteCount: threadNotes.length,
          backgroundGradient: getThreadGradientCSS(thread.color)
        };

        // Note: Active thread is now detected from URL path instead of global state

        pageTitle = thread.title;
        pageContent = `${threadNotes.length} notes`;
      }
    } else if (isNote) {
      // Find note in sample data (check both unorganized and thread notes)
      const note = [...SAMPLE_DATA.unorganizedNotes, ...SAMPLE_DATA.threadNotes].find(n => n.id === id);
      

      
      if (note) {
        content = {
          id: note.id,
          title: note.title,
          content: note.content,
          threadId: note.threadId,
          createdAt: note.createdAt,
          noteId: note.noteId,
          updatedAt: new Date()
        };
        pageTitle = note.title;
        pageContent = note.content.substring(0, 100) + (note.content.length > 100 ? "..." : "");
        
        // Get the thread this note belongs to
        if (note.threadId && note.threadId !== 'thread_unorganized') {
          // Find the actual thread data
          const parentThread = [...SAMPLE_DATA.unorganizedThreads, ...SAMPLE_DATA.organizedThreads]
            .find(t => t.id === note.threadId);
          
          if (parentThread) {
            currentThread = {
              id: parentThread.id,
              title: parentThread.title,
              color: parentThread.color,
              noteCount: SAMPLE_DATA.threadNotes.filter(n => n.threadId === parentThread.id).length,
              backgroundGradient: getThreadGradientCSS(parentThread.color)
            };
            
            // Note: Active thread is now detected from URL path instead of global state
          }
        } else {
          currentThread = {
            id: note.threadId,
            title: "Unorganized",
            noteCount: SAMPLE_DATA.unorganizedNotes.length
          };
        }
      }
    } else if (isSpace) {
      // Find space in sample data
      const space = SAMPLE_DATA.spaces.find(s => s.id === id);
      

      
      if (space) {
        // Get threads for this space
        const spaceThreads = SAMPLE_DATA.organizedThreads.filter(t => t.spaceId === space.id);
        
        content = {
          id: space.id,
          title: space.title,
          color: space.color,
          threads: spaceThreads,
          notes: [],
          threadCount: spaceThreads.length,
          noteCount: 0
        };
        currentSpace = {
          id: space.id,
          title: space.title,
          color: space.color,
          backgroundGradient: getThreadGradientCSS(space.color)
        };
        
        // Note: Active thread is now detected from URL path instead of global state
        
        pageTitle = space.title;
        pageContent = `${spaceThreads.length} threads`;
      }
    }


  // Get navigation data (spaces and inbox count only)
  const navData = getNavigationData();
  spaces = navData.spaces;
  inboxCount = navData.inboxCount;
  
  // Get all threads for navigation (including organized and unorganized)
  threads = [
    ...SAMPLE_DATA.unorganizedThreads,
    ...SAMPLE_DATA.organizedThreads
  ].map(thread => ({
    ...thread,
    noteCount: SAMPLE_DATA.threadNotes.filter(note => note.threadId === thread.id).length
  }));
  */
  
  // Get active thread context for navigation
  const activeThread = await detectActiveThreadFromPath(Astro.url.pathname, userId);

  // Ensure unorganized thread exists in database and check if it has notes
  let unorganizedThread: any = null;
  let otherThreads: any[] = [];
  
  try {
    const threadData = await ensureUnorganizedThread(userId);
    if (threadData.noteCount > 0) {
      unorganizedThread = threadData;
    }
    
    // If we're on the unorganized thread, get other threads to show in navigation
    if (id === 'thread_unorganized') {
      
      const threads = await db.select({
        id: Threads.id,
        title: Threads.title,
        subtitle: Threads.subtitle,
        color: Threads.color,
        spaceId: Threads.spaceId,
        isPublic: Threads.isPublic,
        isPinned: Threads.isPinned,
        createdAt: Threads.createdAt,
        updatedAt: Threads.updatedAt,
      })
      .from(Threads)
      .where(and(
        eq(Threads.userId, userId),
        ne(Threads.id, "thread_unorganized") // Exclude unorganized thread
      ))
      .orderBy(desc(Threads.isPinned), desc(Threads.updatedAt || Threads.createdAt));

      // Get note counts for each thread
      otherThreads = await Promise.all(
        threads.map(async (thread) => {
          const threadNoteCount = await db.select({ count: count() })
            .from(Notes)
            .innerJoin(NoteThreads, eq(NoteThreads.noteId, Notes.id))
            .where(and(
              eq(NoteThreads.threadId, thread.id),
              eq(Notes.userId, userId)
            ))
            .get();

          return {
            ...thread,
            noteCount: threadNoteCount?.count || 0,
            backgroundGradient: thread.color 
              ? getThreadGradientCSS(thread.color)
              : 'var(--color-gradient-gray)'
          };
        })
      );
    }
  } catch (error) {
    console.error("Thread page: Error checking unorganized thread notes:", error);
  }

  // Always use real database data
  try {
    if (isThread) {
      // Special handling for unorganized thread
      if (id === 'thread_unorganized') {
        // Ensure the unorganized thread exists in database
        await ensureUnorganizedThread(userId);
        
        const notesData = await getNotesForThread(id!, userId);
        
        content = {
          id: 'thread_unorganized',
          title: 'Unorganized',
          subtitle: 'Individual notes and unassigned content',
          color: null,
          spaceId: null,
          notes: notesData,
          noteCount: notesData.length
        };
        currentThread = {
          id: 'thread_unorganized',
          title: 'Unorganized',
          color: null,
          noteCount: notesData.length,
          backgroundGradient: getThreadGradientCSS('paper')
        };
        
        // Set threadNotes for template rendering
        threadNotes = notesData;
        
        pageTitle = 'Unorganized';
        pageContent = `${notesData.length} notes`;
      } else {
        // Fetch thread and its notes from database
        const [threadData, notesData] = await Promise.all([
          getAllThreadsWithCounts(userId).then(threads => threads.find(t => t.id === id)),
          getNotesForThread(id!, userId)
        ]);
        
        if (threadData) {
          content = {
            id: threadData.id,
            title: threadData.title,
            subtitle: threadData.subtitle,
            color: threadData.color,
            spaceId: threadData.spaceId,
            notes: notesData,
            noteCount: notesData.length
          };
          currentThread = {
            id: threadData.id,
            title: threadData.title,
            color: threadData.color,
            noteCount: notesData.length,
            backgroundGradient: getThreadGradientCSS(threadData.color)
          };
          
          // Set threadNotes for template rendering
          threadNotes = notesData;
          
          pageTitle = threadData.title;
          pageContent = `${notesData.length} notes`;
          
          // Track thread context for smart navigation
          console.log('üßµ Tracking thread context for smart navigation:', threadData.id);
        }
      }
    } else if (isNote) {
      // Fetch note from database
      const note = await db.select().from(Notes).where(eq(Notes.id, id!)).get();
      
      if (note) {
        // Fetch scripture metadata if this is a scripture note
        let version: string | undefined;
        if (note.noteType === 'scripture') {
          try {
            const scriptureMeta = await db.select()
              .from(ScriptureMetadata)
              .where(eq(ScriptureMetadata.noteId, note.id))
              .get();
            version = scriptureMeta?.translation;
            
            // Log for debugging (only in development or when debugging is needed)
            if (scriptureMeta) {
              console.log(`[id].astro] ScriptureMetadata found for note ${note.id}: version=${version}`);
            } else {
              console.log(`[id].astro] ScriptureMetadata not found for scripture note ${note.id}`);
            }
          } catch (error: any) {
            // Log error but don't fail page load - version will remain undefined
            console.error(`[id].astro] Error fetching ScriptureMetadata for note ${note.id}:`, error.message || error);
            // Check if it's a "table doesn't exist" error which indicates schema mismatch
            if (error.message?.includes('no such table') || error.message?.includes('SQLITE_ERROR')) {
              console.error(`[id].astro] ‚ö†Ô∏è CRITICAL: ScriptureMetadata table may not exist in production database. Run 'npm run db:push' to sync schema.`);
            }
          }
        }

        content = {
          id: note.id,
          title: note.title,
          content: note.content,
          threadId: note.threadId,
          createdAt: note.createdAt,
          noteId: note.simpleNoteId,
          updatedAt: note.updatedAt,
          noteType: note.noteType || 'default',
          version
        };

        // Set page title for note
        pageTitle = note.title || "Untitled Note";

        // Smart Default Logic for Multi-Thread Navigation
        // 1. Check URL parameter for specific thread context
        const urlParams = new URL(Astro.url.href).searchParams;
        const requestedThreadId = urlParams.get('thread');
        
        let selectedThreadId = null; // No default - will be determined by logic below
        
        if (requestedThreadId) {
          // Verify the requested thread exists and note belongs to it
          const noteThreads = await db.select()
            .from(NoteThreads)
            .where(eq(NoteThreads.noteId, note.id))
            .all();
          
          const threadIds = noteThreads.map(nt => nt.threadId);
          if (threadIds.includes(requestedThreadId)) {
            selectedThreadId = requestedThreadId;
          }
        } else {
          // 2. Smart Default: Use navigation context if available
          // Check if user was recently viewing a thread that this note belongs to
          const noteThreads = await db.select()
            .from(NoteThreads)
            .where(eq(NoteThreads.noteId, note.id))
            .all();
          
          // Pure junction table approach: Only use junction table for thread relationships
          // Primary threadId is only used for unorganized notes (fallback)
          let allThreadIds = [...noteThreads.map(nt => nt.threadId)];
          
          // Only include primary threadId if it's unorganized (fallback case)
          if (note.threadId === 'thread_unorganized') {
            allThreadIds.push('thread_unorganized');
          }
          
          // Remove duplicates
          const uniqueThreadIds = [...new Set(allThreadIds)];
          
          if (uniqueThreadIds.length > 1) {
            // Note belongs to multiple threads - use smart default
            console.log('üîç Note belongs to multiple threads:', uniqueThreadIds);
            
            // Enhanced breadcrumb-like logic for thread context detection
            let navigationHistoryThreadId = null;
            try {
              // 1. Check referrer for thread context (server-side approach)
              const referrer = Astro.request.headers.get('referer');
              console.log('üîç Server-side: Checking referrer for thread context...');
              console.log('üîç Server-side: Raw referrer:', referrer);
              
              if (referrer) {
                try {
                  const referrerUrl = new URL(referrer);
                  const referrerPath = referrerUrl.pathname;
                  console.log('üîç Server-side: Referrer path:', referrerPath);
                  
                  // Check if referrer is a thread page
                  if (referrerPath.includes('/thread_')) {
                    const threadId = referrerPath.split('/').pop();
                    console.log('üîç Server-side: Extracted thread ID from referrer:', threadId);
                    
                    if (threadId && threadId !== 'dashboard' && threadId !== 'sign-in' && threadId !== 'sign-up') {
                      // Verify this thread is one the note belongs to
                      if (uniqueThreadIds.includes(threadId)) {
                        navigationHistoryThreadId = threadId;
                        console.log('üîó Server-side: Using referrer thread context:', navigationHistoryThreadId);
                      } else {
                        console.log('üîó Server-side: Referrer thread not in note threads, skipping');
                        console.log('  - Referrer thread:', threadId);
                        console.log('  - Note threads:', uniqueThreadIds);
                      }
                    } else {
                      console.log('üîó Server-side: Invalid thread ID from referrer');
                    }
                  } else {
                    console.log('üîó Server-side: Referrer is not a thread page');
                  }
                } catch (parseError) {
                  console.log('üîó Server-side: Could not parse referrer URL:', parseError);
                }
              } else {
                console.log('üîó Server-side: No referrer available');
              }
              
              // 2. Removed: NoteThreadAccess table tracking (complexity reduction)

              // 3. Fallback: Use the most recently updated thread
              if (!navigationHistoryThreadId) {
                console.log('üîó Server-side: No referrer or access context, using fallback logic');
              }
            } catch (error) {
              console.log('Could not access navigation history:', error);
            }
            
            if (navigationHistoryThreadId) {
              // Use the thread from navigation history
              selectedThreadId = navigationHistoryThreadId;
            } else {
              // Fallback: Use the most recently updated thread
              const threads = await Promise.all(
                uniqueThreadIds.map(async (threadId) => {
                  const thread = await db.select()
                    .from(Threads)
                    .where(and(eq(Threads.id, threadId), eq(Threads.userId, userId)))
                    .get();
                  return thread;
                })
              );
              
              // Filter out null results and sort by most recent
              const validThreads = threads.filter(thread => thread !== null)
                .sort((a, b) => {
                  if (!a || !b) return 0;
                  const aTime = a.updatedAt || a.createdAt;
                  const bTime = b.updatedAt || b.createdAt;
                  return bTime.getTime() - aTime.getTime();
                });
              
              if (validThreads.length > 0 && validThreads[0]) {
                selectedThreadId = validThreads[0].id;
                console.log('üîÑ Using fallback thread (most recent):', selectedThreadId);
              }
            }
          } else if (uniqueThreadIds.length === 1) {
            // Note belongs to only one thread - use that thread
            selectedThreadId = uniqueThreadIds[0];
            console.log('üîç Note belongs to single thread:', selectedThreadId);
          } else {
            // Note has no threads - use unorganized thread as fallback
            selectedThreadId = 'thread_unorganized';
            console.log('üîç Note has no threads, using unorganized fallback');
          }
        }

        // Get the selected thread context
        if (selectedThreadId === 'thread_unorganized') {
          // Special handling for unorganized thread
          const noteCount = await getNotesForThread('thread_unorganized', userId).then(notes => notes.length);
          currentThread = {
            id: 'thread_unorganized',
            title: 'Unorganized',
            color: null,
            noteCount: noteCount,
            backgroundGradient: getThreadGradientCSS('paper')
          };
        } else if (selectedThreadId) {
          const thread = await db.select().from(Threads).where(eq(Threads.id, selectedThreadId)).get();
          
          if (thread) {
            currentThread = {
              id: thread.id,
              title: thread.title,
              color: thread.color,
              noteCount: await getNotesForThread(thread.id, userId).then(notes => notes.length),
              backgroundGradient: getThreadGradientCSS(thread.color)
            };
          }
        } else {
          // Fallback: no valid thread selected, use unorganized
          const noteCount = await getNotesForThread('thread_unorganized', userId).then(notes => notes.length);
          currentThread = {
            id: 'thread_unorganized',
            title: 'Unorganized',
            color: null,
            noteCount: noteCount,
            backgroundGradient: getThreadGradientCSS('paper')
          };
        }

        // Removed: NoteThreadAccess tracking (complexity reduction)
      }
    } else if (isSpace) {
      // Fetch space, its threads, and standalone notes from database
      const [spaceData, spaceThreads, spaceNotes] = await Promise.all([
        getSpacesWithCounts(userId).then(spaces => spaces.find(s => s.id === id)),
        getThreadsForSpace(id!, userId),
        getNotesForSpace(id!, userId)
      ]);
      
      if (spaceData) {
        content = {
          id: spaceData.id,
          title: spaceData.title,
          totalItemCount: spaceData.totalItemCount,
          color: spaceData.color,
          threads: spaceThreads,
          notes: spaceNotes // Standalone notes in this space
        };
        currentSpace = {
          id: spaceData.id,
          title: spaceData.title,
          color: spaceData.color,
          totalItemCount: spaceData.totalItemCount,
          backgroundGradient: getThreadGradientCSS(spaceData.color)
        };
        
        threads = spaceThreads;
        pageTitle = spaceData.title;
        pageContent = `${spaceData.totalItemCount} items`;
      }
    }

    // Get navigation data from database
    const [allThreads, allSpaces, inboxCountData] = await Promise.all([
      getAllThreadsWithCounts(userId),
      getSpacesWithCounts(userId),
      getInboxDisplayCount(userId)
    ]);
    
    spaces = allSpaces;
    threads = [...allThreads, ...threads]; // Combine with space-specific threads
    inboxCount = inboxCountData;
    
  } catch (error) {
    console.error("Error fetching data from database:", error);
    // Fallback to empty data
    content = null;
    threads = [];
    spaces = [];
    inboxCount = 0;
  }



// If content not found, redirect to dashboard
if (!content) {
  // return Astro.redirect('/dashboard'); // Temporarily disabled for static mode
}
---

<Layout title={pageTitle} contentType={contentType} contentId={id} currentThread={currentThread} currentSpace={currentSpace} currentNote={isNote ? content : null}>
  <!-- Navigation Column -->
  <NavigationColumnReact 
    slot="navigation"
    inboxCount={inboxCount}
    spaces={spaces}
    activeThread={currentThread}
    currentSpace={currentSpace}
    isNote={isNote}
    currentId={id}
    showProfile={false}
    initials={initials}
    userColor={userColor}
    data-parent-thread-id={isNote ? (currentThread?.id || 'thread_unorganized') : undefined}
    data-parent-thread-title={isNote ? (currentThread?.title || 'Unorganized') : undefined}
    data-parent-thread-count={isNote ? (currentThread?.noteCount || 0) : undefined}
    data-parent-thread-background-gradient={isNote ? (currentThread?.backgroundGradient || getThreadGradientCSS('blue')) : undefined}
  />

  <!-- Main Column -->
  <div slot="main" class="h-full min-h-0 overflow-hidden" data-navigation-item={id} data-title={pageTitle} data-count={isNote ? 0 : (currentThread?.noteCount || currentSpace?.threadCount || 0)} data-background-gradient={isNote ? "var(--color-gradient-gray)" : (currentThread?.backgroundGradient || currentSpace?.backgroundGradient || "var(--color-gradient-gray)")}>
          {isNote && content ? (
            <div 
              data-note-id={content.id}
              data-parent-thread-id={currentThread?.id || 'thread_unorganized'}
              data-parent-thread-title={currentThread?.title || 'Unorganized'}
              data-parent-thread-count={currentThread?.noteCount || 0}
              data-parent-thread-background-gradient={currentThread?.backgroundGradient || getThreadGradientCSS('blue')}
              data-parent-thread-color={currentThread?.color || 'blue'}
              data-selected-thread-id={currentThread?.id || 'thread_unorganized'}
              class="h-full min-h-0 overflow-hidden flex flex-col"
              style={{ maxHeight: '100%' }}
            >
              <CardFullEditableReact 
                title={content.title || "Untitled Note"}
                content={content.content}
                date={content.createdAt ? content.createdAt.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : "Feb 7, 2025"}
                noteId={content.noteId ? `N${content.noteId.toString().padStart(3, '0')}` : undefined}
                noteType={content.noteType || 'default'}
                version={content.version}
                className="h-full flex-1 min-h-0"
              />
            </div>
          ) : !content ? (
            <div class="flex flex-col items-center justify-center min-h-[400px] w-full text-center">
              <div class="flex flex-col gap-2 items-center justify-center">
                <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                  <p>Content not found</p>
                </div>
                <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                  <p>The requested content could not be found or loaded.</p>
                </div>
              </div>
            </div>
          ) : (
            <CardStack 
              title={pageTitle} 
              subtitle={isThread ? undefined : pageContent} 
              headerBgColor={isThread && currentThread?.color ? `var(--color-${currentThread.color})` : "var(--color-paper)"}
              centerTitle={isThread}
            >
              <div class="flex flex-col gap-6">
                
                {isThread && threadNotes && threadNotes.length > 0 ? (
                  <div class="flex flex-col gap-3">
                    {threadNotes.map((note: any) => (
                      <div class="content-item note-item">
                        <a 
                          href={`/${note.id}`}
                          class="block transition-transform duration-200 hover:scale-[1.002]"
                        >
                          <CardNote 
                            title={note.title || "Untitled Note"}
                            content={(() => {
                              const cleanContent = stripHtml(note.content);
                              return cleanContent.substring(0, 150) + (cleanContent.length > 150 ? "..." : "");
                            })()}
                            noteType={note.noteType || 'default'}
                          />
                        </a>
                      </div>
                    ))}
                  </div>
                ) : isSpace && content && content.threads && content.threads.length > 0 ? (
                  <div class="flex flex-col gap-3">
                    {/* Show threads in this space */}
                    {content?.threads.map((thread: any) => (
                      <div class="content-item thread-item">
                        <a 
                          href={`/${thread.id}`}
                          class="block transition-transform duration-200 hover:scale-[1.002]"
                        >
                          <CardThread 
                            title={thread.title}
                            subtitle={thread.subtitle || `${thread.noteCount} notes`}
                            count={thread.noteCount}
                            accentColor={thread.accentColor}
                            lastUpdated={thread.lastUpdated}
                            isPrivate={!thread.isPublic}
                          />
                        </a>
                      </div>
                    ))}
                    
                    {/* Show standalone notes in this space */}
                    {content?.notes && content.notes.length > 0 && content.notes.map((note: any) => (
                      <div class="content-item note-item">
                        <a 
                          href={`/${note.id}`}
                          class="block transition-transform duration-200 hover:scale-[1.002]"
                        >
                          <CardNote 
                            title={note.title || "Untitled Note"}
                            content={(() => {
                              const cleanContent = stripHtml(note.content);
                              return cleanContent.substring(0, 150) + (cleanContent.length > 150 ? "..." : "");
                            })()}
                            noteType={note.noteType || 'default'}
                          />
                        </a>
                      </div>
                    ))}
                  </div>
                ) : isThread ? (
                  <div class="text-center py-12">
                    <p>No notes found in this thread.</p>
                  </div>
                ) : (
                  <div class="text-center py-12">
                    <p class="text-[var(--color-pebble-grey)] text-lg">No content found.</p>
                  </div>
                )}
              </div>
            </CardStack>
          )}
  </div>

  <!-- Mobile Navigation -->
  <div slot="mobile-navigation">

    <MobileNavigation 
      spaces={spaces}
      threads={threads}
      inboxCount={inboxCount}
      currentSpace={currentSpace}
      currentThread={currentThread}
      initials={initials}
      userColor={userColor}
    />
  </div>

  <!-- Mobile Additional -->
  <div slot="mobile-additional">
    <MobileAdditional contentType={contentType} contentId={id} currentThread={currentThread} currentSpace={isSpace && content ? content : null} />
  </div>

</Layout>

<script type="text/javascript">
  console.log('üöÄ Client-side script in [id].astro is running!'); // Added for debugging
  // Set the global save callback for CardFullEditable
  var noteSaveCallback = async function(newTitle, newContent) {
    try {
      // Get note ID from the data attribute on the container
      const container = document.querySelector('[data-note-id]');
      const noteId = container?.getAttribute('data-note-id');
      
      
      if (!noteId) {
        throw new Error('Note ID not found');
      }
      
      const response = await fetch('/api/notes/update', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          noteId: noteId,
          title: newTitle,
          content: newContent
        })
      });
      
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Note page: API error response:', errorText);
        throw new Error('Failed to update note');
      }
      
      const result = await response.json();
      return result;
    } catch (error) {
      console.error('Error updating note:', error);
      throw error;
    }
  };
  
  // Listen for note thread changes and refresh the page
  document.addEventListener('noteAddedToThread', async (event) => {
    const { noteId, threadId } = event.detail;
    console.log('üîµ Thread page: Note added to thread event received:', { noteId, threadId });
    console.log('üîµ Thread page: Current URL:', window.location.pathname);
    console.log('üîµ Thread page: Current thread ID from URL:', window.location.pathname.substring(1));
    
    // Check if we're on the affected thread page
    const currentThreadId = window.location.pathname.substring(1);
    if (currentThreadId === threadId) {
      console.log('üîµ Thread page: Refreshing thread data after note added');
      // Refresh the page to show updated note list
      window.location.reload();
    } else {
      console.log('üîµ Thread page: Not the affected thread, no refresh needed');
    }
  });
  
  document.addEventListener('noteRemovedFromThread', async (event) => {
    const { noteId, threadId } = event.detail;
    console.log('üî¥ Thread page: Note removed from thread event received:', { noteId, threadId });
    console.log('üî¥ Thread page: Current URL:', window.location.pathname);
    console.log('üî¥ Thread page: Current thread ID from URL:', window.location.pathname.substring(1));
    
    // Check if we're on the affected thread page
    const currentThreadId = window.location.pathname.substring(1);
    if (currentThreadId === threadId) {
      console.log('üî¥ Thread page: Refreshing thread data after note removed');
      // Refresh the page to show updated note list
      window.location.reload();
    } else {
      console.log('üî¥ Thread page: Not the affected thread, no refresh needed');
    }
  });
  
  // Test function to manually trigger events (for debugging)
  window.testThreadEvents = function() {
    console.log('üß™ Testing thread events...');
    
    // Test noteAddedToThread event
    const addEvent = new CustomEvent('noteAddedToThread', {
      detail: { noteId: 'test_note_123', threadId: window.location.pathname.substring(1) }
    });
    document.dispatchEvent(addEvent);
    
    // Test noteRemovedFromThread event
    setTimeout(() => {
      const removeEvent = new CustomEvent('noteRemovedFromThread', {
        detail: { noteId: 'test_note_123', threadId: window.location.pathname.substring(1) }
      });
      document.dispatchEvent(removeEvent);
    }, 2000);
  };
  
  // Debug function to check breadcrumb data
  window.debugBreadcrumb = function() {
    console.log('üçû Debugging breadcrumb data...');
    const breadcrumbData = localStorage.getItem('harvous-breadcrumb-navigation');
    console.log('Raw breadcrumb data:', breadcrumbData);
    
    if (breadcrumbData) {
      try {
        const parsed = JSON.parse(breadcrumbData);
        console.log('Parsed breadcrumb data:', parsed);
        const age = Date.now() - parsed.timestamp;
        console.log('Breadcrumb age (minutes):', Math.round(age / 60000));
        console.log('Current note ID:', window.location.pathname.substring(1));
        console.log('Breadcrumb matches current note:', parsed.toNoteId === window.location.pathname.substring(1));
      } catch (error) {
        console.log('Error parsing breadcrumb data:', error);
      }
    }
    
    // Check other context data
    console.log('Current thread context:', localStorage.getItem('harvous-current-thread-context'));
    console.log('Referrer thread context:', localStorage.getItem('harvous-referrer-thread-context'));
  };
  
  // Detect page type (client-side)
  const currentPath = window.location.pathname;
  console.log('üîç Current path:', currentPath); // Added for debugging
  
  // More specific detection logic
  const isThread = currentPath.includes('/thread_') || (currentPath.match(/^\/thread_[a-zA-Z0-9_-]+$/) && !currentPath.includes('/dashboard') && !currentPath.includes('/sign-in') && !currentPath.includes('/sign-up'));
  const isNote = currentPath.includes('/note_') || (currentPath.match(/^\/note_[a-zA-Z0-9_-]+$/) && !currentPath.includes('/dashboard') && !currentPath.includes('/sign-in') && !currentPath.includes('/sign-up'));
  
  console.log('üîç Detection logic:', {
    path: currentPath,
    includesThread: currentPath.includes('/thread_'),
    includesNote: currentPath.includes('/note_'),
    matchesThread: currentPath.match(/^\/thread_[a-zA-Z0-9_-]+$/),
    matchesNote: currentPath.match(/^\/note_[a-zA-Z0-9_-]+$/)
  });
  
  console.log('üîç Page type detection:', { currentPath, isThread, isNote });
  
  // Check if Layout.astro functions are available
  console.log('üîç Available functions:', {
    trackThreadContext: typeof window.trackThreadContext,
    trackBreadcrumbNavigation: typeof window.trackBreadcrumbNavigation,
    getThreadContextFromReferrer: typeof window.getThreadContextFromReferrer
  });
  
  // Track thread context for smart navigation (only on thread pages)
  if (window.trackThreadContext && isThread) {
    const threadId = window.location.pathname.substring(1);
    window.trackThreadContext(threadId);
    console.log('üßµ Tracked thread context:', threadId);
  } else if (isNote) {
    console.log('üßµ Note page: Not tracking thread context (this is correct)');
  }
  
  // Enhanced breadcrumb navigation tracking (on thread pages)
  if (isThread) {
    const threadId = window.location.pathname.substring(1);
    console.log('üßµ Thread page: Setting up breadcrumb tracking for thread:', threadId);
    
    // Track referrer-based context for breadcrumb navigation
    if (window.getThreadContextFromReferrer) {
      const referrerThreadId = window.getThreadContextFromReferrer();
      if (referrerThreadId) {
        localStorage.setItem('harvous-referrer-thread-context', referrerThreadId);
        console.log('üîó Tracked referrer thread context:', referrerThreadId);
      }
    }
    
    // Add click handlers to note links for breadcrumb tracking
    document.addEventListener('click', function(event) {
      const link = event.target.closest('a[href]');
      if (link) {
        const href = link.getAttribute('href');
        console.log('üîç Thread page: Click detected on link:', href);
        
        // Check if it's a note link (starts with / and contains note ID pattern)
        if (href && href.startsWith('/') && href.length > 1) {
          const noteId = href.split('/').pop();
          console.log('üîç Thread page: Extracted note ID:', noteId);
          
          // Check if it looks like a note ID (not a thread or space ID)
          if (noteId && noteId !== 'dashboard' && noteId !== 'sign-in' && noteId !== 'sign-up' && !noteId.startsWith('thread_') && !noteId.startsWith('space_')) {
            console.log('üçû Thread page: Note link detected, tracking breadcrumb...');
            if (window.trackBreadcrumbNavigation) {
              window.trackBreadcrumbNavigation(threadId, noteId);
              console.log('üçû Thread page: Tracked breadcrumb navigation from thread to note:', { fromThread: threadId, toNote: noteId });
            } else {
              console.log('‚ùå Thread page: trackBreadcrumbNavigation function not available');
            }
          } else {
            console.log('üîç Thread page: Not a note link, skipping breadcrumb tracking');
          }
        }
      }
    });
  } else if (isNote) {
    console.log('üßµ Note page: Not setting up breadcrumb tracking (this is correct)');
  }
  
  // Debug breadcrumb data on note pages
  if (isNote) {
    console.log('üçû Note page: Checking for breadcrumb data...');
    
    // Wrap in try-catch to prevent script breaking
    try {
      const breadcrumbData = localStorage.getItem('harvous-breadcrumb-navigation');
      if (breadcrumbData) {
        try {
          const parsed = JSON.parse(breadcrumbData);
          console.log('üçû Note page: Found breadcrumb data:', parsed);
          const age = Date.now() - parsed.timestamp;
          console.log('üçû Note page: Breadcrumb age (minutes):', Math.round(age / 60000));
          console.log('üçû Note page: Current note ID:', window.location.pathname.substring(1));
          console.log('üçû Note page: Breadcrumb matches current note:', parsed.toNoteId === window.location.pathname.substring(1));
          
          // Check if the breadcrumb data is valid
          if (parsed.fromThreadId && parsed.toNoteId && parsed.timestamp) {
            console.log('üçû Note page: Breadcrumb data is valid');
            console.log('üçû Note page: From thread:', parsed.fromThreadId);
            console.log('üçû Note page: To note:', parsed.toNoteId);
            console.log('üçû Note page: Timestamp:', new Date(parsed.timestamp).toLocaleString());
            
            // Apply the breadcrumb context immediately
            console.log('üçû Note page: Applying breadcrumb context to localStorage...');
            localStorage.setItem('harvous-current-thread-context', parsed.fromThreadId);
            localStorage.setItem('harvous-thread-context-timestamp', Date.now().toString());
            console.log('üçû Note page: Applied thread context:', parsed.fromThreadId);
            
            // Force update the React component with the correct thread context
            console.log('üçû Note page: Forcing React component update...');
            setTimeout(() => {
              try {
                // Update the data attributes on the container
                const container = document.querySelector('[data-note-id]');
                if (container) {
                  container.setAttribute('data-selected-thread-id', parsed.fromThreadId);
                  container.setAttribute('data-parent-thread-id', parsed.fromThreadId);
                  console.log('üçû Note page: Updated container data attributes with thread:', parsed.fromThreadId);
                  
                  // Trigger a custom event to update the React component
                  const event = new CustomEvent('breadcrumbContextUpdate', {
                    detail: { threadId: parsed.fromThreadId }
                  });
                  window.dispatchEvent(event);
                  console.log('üçû Note page: Dispatched breadcrumb context update event');
                } else {
                  console.log('üçû Note page: Container not found, cannot update data attributes');
                }
              } catch (updateError) {
                console.log('üçû Note page: Error updating container:', updateError);
              }
            }, 100);
          } else {
            console.log('üçû Note page: Breadcrumb data is invalid or incomplete');
          }
        } catch (parseError) {
          console.log('üçû Note page: Error parsing breadcrumb data:', parseError);
        }
      } else {
        console.log('üçû Note page: No breadcrumb data found');
      }
    } catch (breadcrumbError) {
      console.log('üçû Note page: Error in breadcrumb logic:', breadcrumbError);
    }
  }
  
</script>


