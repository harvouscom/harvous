---
import Layout from "@/layouts/Layout.astro";
import CardStack from "@/components/CardStack.astro";
import SearchInput from "@/components/SearchInput.astro";
import TabNav from "@/components/TabNav.astro";
import CardNote from "@/components/CardNote.astro";
import CardThread from "@/components/CardThread.astro";
import NavigationColumnReact from "@/components/NavigationColumnReact.astro";
import SquareButton from "@/components/SquareButton.astro";
import Avatar from "@/components/Avatar.astro";
import MobileNavigation from "@/components/MobileNavigation.astro";
import MobileAdditional from "@/components/MobileAdditional.astro";
import RecentSearches from "@/components/react/RecentSearches";
import { db, Notes, Threads, Tags, NoteTags, eq, and, or, like, desc, count } from "astro:db";
import { getThreadColorCSS } from "@/utils/colors";

// Helper function to strip HTML tags and decode entities
function stripHtml(html: string): string {
  if (!html) return '';
  
  // More aggressive HTML stripping
  let text = html
    // Remove script and style tags completely (including their content)
    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '')
    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '')
    // Remove all HTML tags (including those with complex attributes)
    .replace(/<[^>]*>/g, '')
    // Decode HTML entities
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&#x27;/g, "'")
    .replace(/&#x2F;/g, '/')
    .replace(/&#x60;/g, '`')
    .replace(/&#x3D;/g, '=')
    // Clean up whitespace
    .replace(/\s+/g, ' ')
    .trim();
    
  return text;
}

// Helper function to format relative time (same as dashboard)
function formatRelativeTime(date: Date): string {
  const now = new Date();
  const diffInMs = now.getTime() - date.getTime();
  const diffInDays = Math.floor(diffInMs / (1000 * 60 * 60 * 24));
  const diffInHours = Math.floor(diffInMs / (1000 * 60 * 60));
  const diffInMinutes = Math.floor(diffInMs / (1000 * 60));

  if (diffInDays > 0) {
    return diffInDays === 1 ? "1 day ago" : `${diffInDays} days ago`;
  } else if (diffInHours > 0) {
    return diffInHours === 1 ? "1 hour ago" : `${diffInHours} hours ago`;
  } else if (diffInMinutes > 0) {
    return diffInMinutes === 1 ? "1 minute ago" : `${diffInMinutes} minutes ago`;
  } else {
    return "Just now";
  }
}

// Get user data from Clerk authentication
const auth = Astro.locals.auth();
const { userId } = auth;

if (!userId) {
  return Astro.redirect('/sign-in');
}

// Try to fetch user data from Clerk API using secret key
let userData: any = null;
try {
  const clerkSecretKey = import.meta.env.CLERK_SECRET_KEY;
  if (clerkSecretKey) {
    const response = await fetch(`https://api.clerk.com/v1/users/${userId}`, {
      headers: {
        'Authorization': `Bearer ${clerkSecretKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    if (response.ok) {
      userData = await response.json();
    }
  }
} catch (error) {
  console.log('Error fetching user data:', error);
}

// Extract user data from API response or use fallbacks
const firstName = userData?.first_name || userData?.firstName || '';
const lastName = userData?.last_name || userData?.lastName || '';
const initials = `${firstName.charAt(0) || ''}${lastName.charAt(0) || ''}`.toUpperCase() || 'U';

// Get user color from database
let userColor = 'paper'; // default
try {
  const { UserMetadata } = await import('astro:db');
  const userMetadata = await db.select().from(UserMetadata).where(eq(UserMetadata.userId, userId)).get();
  userColor = userMetadata?.userColor || 'paper';
} catch (error) {
  console.log('Error fetching user color:', error);
}

// Get search query from URL parameters
const url = new URL(Astro.request.url);
const query = url.searchParams.get('q') || '';
const activeTab = url.searchParams.get('tab') || 'all';

// Search results
let searchResults: any[] = [];
let notesResults: any[] = [];
let threadsResults: any[] = [];

// Perform search if query exists
if (query.trim()) {
  try {
    const searchTerm = `%${query.trim()}%`;
    const searchTermLower = `%${query.trim().toLowerCase()}%`;
    
    // Enhanced search with multiple patterns for better matching
    const searchPatterns = [
      searchTerm,           // exact case match
      searchTermLower,     // lowercase match
      `%${query.trim().split(' ').join('%')}%`, // word boundary match
    ];
    
    // Check if query is numeric or has "N" prefix (for note ID search)
    const queryTrimmed = query.trim();
    // Check for "N" prefix (case-insensitive) followed by digits
    const nPrefixMatch = queryTrimmed.match(/^[nN](\d+)$/);
    // Check if query is purely numeric
    const isNumericQuery = /^\d+$/.test(queryTrimmed);
    // Extract numeric note ID from either pattern
    const numericNoteId = nPrefixMatch 
      ? parseInt(nPrefixMatch[1], 10) 
      : (isNumericQuery ? parseInt(queryTrimmed, 10) : null);
    const hasNoteIdSearch = numericNoteId !== null;
    
    // Build search conditions for notes
    const noteSearchConditions = [
      like(Notes.title, searchPatterns[0]),
      like(Notes.content, searchPatterns[0]),
      like(Notes.title, searchPatterns[1]),
      like(Notes.content, searchPatterns[1]),
      like(Notes.title, searchPatterns[2]),
      like(Notes.content, searchPatterns[2])
    ];
    
    // Add note ID search if query is numeric or has "N" prefix
    if (hasNoteIdSearch && numericNoteId !== null) {
      noteSearchConditions.push(eq(Notes.simpleNoteId, numericNoteId));
    }
    
    // Search notes with enhanced matching (including tags)
    // First, get notes that match title/content/ID
    const notesByContent = await db
      .select({
        id: Notes.id,
        title: Notes.title,
        content: Notes.content,
        threadId: Notes.threadId,
        spaceId: Notes.spaceId,
        simpleNoteId: Notes.simpleNoteId,
        noteType: Notes.noteType,
        createdAt: Notes.createdAt,
        updatedAt: Notes.updatedAt,
        userId: Notes.userId,
        isPublic: Notes.isPublic,
        isFeatured: Notes.isFeatured,
        order: Notes.order
      })
      .from(Notes)
      .where(
        and(
          eq(Notes.userId, userId),
          or(...noteSearchConditions)
        )
      )
      .orderBy(desc(Notes.updatedAt), desc(Notes.createdAt));

    // Then, get notes that match tags (without duplicates)
    const notesByTags = await db
      .select({
        id: Notes.id,
        title: Notes.title,
        content: Notes.content,
        threadId: Notes.threadId,
        spaceId: Notes.spaceId,
        simpleNoteId: Notes.simpleNoteId,
        noteType: Notes.noteType,
        createdAt: Notes.createdAt,
        updatedAt: Notes.updatedAt,
        userId: Notes.userId,
        isPublic: Notes.isPublic,
        isFeatured: Notes.isFeatured,
        order: Notes.order
      })
      .from(Notes)
      .innerJoin(NoteTags, eq(Notes.id, NoteTags.noteId))
      .innerJoin(Tags, eq(NoteTags.tagId, Tags.id))
      .where(
        and(
          eq(Notes.userId, userId),
          or(
            like(Tags.name, searchPatterns[0]),
            like(Tags.name, searchPatterns[1]),
            like(Tags.name, searchPatterns[2])
          )
        )
      )
      .orderBy(desc(Notes.updatedAt), desc(Notes.createdAt));

    // Combine and deduplicate results
    const allNotes = [...notesByContent, ...notesByTags];
    const uniqueNotes = allNotes.filter((note, index, self) => 
      index === self.findIndex(n => n.id === note.id)
    );
    
    // Sort by date
    const notes = uniqueNotes.sort((a, b) => 
      new Date(b.updatedAt || b.createdAt).getTime() - new Date(a.updatedAt || a.createdAt).getTime()
    );

    // Search threads with enhanced matching
    const threads = await db
      .select()
      .from(Threads)
      .where(
        and(
          eq(Threads.userId, userId),
          or(
            like(Threads.title, searchPatterns[0]),
            like(Threads.title, searchPatterns[1]),
            like(Threads.title, searchPatterns[2])
          )
        )
      )
      .orderBy(desc(Threads.updatedAt), desc(Threads.createdAt));

    // Helper function to calculate relevance score
    function calculateRelevanceScore(item: any, query: string): number {
      const queryLower = query.toLowerCase();
      const queryTrimmed = query.trim();
      const titleLower = (item.title || '').toLowerCase();
      const contentLower = (item.content || '').toLowerCase();
      const tagsLower = (item.tags || []).map((tag: any) => tag.name.toLowerCase()).join(' ');
      
      let score = 0;
      
      // Note ID matches get highest score (highest priority)
      if (hasNoteIdSearch && item.simpleNoteId && item.simpleNoteId === numericNoteId) {
        score += 200; // Highest priority for exact ID match
      }
      
      // Title matches get highest score
      if (titleLower.includes(queryLower)) {
        score += 100;
        // Exact title match gets bonus
        if (titleLower === queryLower) score += 50;
        // Title starts with query gets bonus
        if (titleLower.startsWith(queryLower)) score += 25;
      }
      
      // Content matches get medium score
      if (contentLower.includes(queryLower)) {
        score += 50;
        // Multiple occurrences in content get bonus
        const occurrences = (contentLower.match(new RegExp(queryLower, 'g')) || []).length;
        score += occurrences * 10;
      }
      
      // Tag matches get high score (between title and content)
      if (tagsLower.includes(queryLower)) {
        score += 75;
        // Multiple tag matches get bonus
        const tagOccurrences = (tagsLower.match(new RegExp(queryLower, 'g')) || []).length;
        score += tagOccurrences * 15;
      }
      
      // Recent content gets slight boost
      const daysSinceUpdate = Math.floor((Date.now() - new Date(item.updatedAt || item.createdAt).getTime()) / (1000 * 60 * 60 * 24));
      if (daysSinceUpdate < 7) score += 10;
      if (daysSinceUpdate < 30) score += 5;
      
      return score;
    }

    // Get tags for each note
    const notesWithTags = await Promise.all(
      notes.map(async (note) => {
        try {
          const noteTags = await db
            .select({
              id: Tags.id,
              name: Tags.name,
              color: Tags.color,
              category: Tags.category
            })
            .from(NoteTags)
            .innerJoin(Tags, eq(NoteTags.tagId, Tags.id))
            .where(and(eq(NoteTags.noteId, note.id), eq(Tags.userId, userId)));

          return { ...note, tags: noteTags };
        } catch (error) {
          console.log('Error fetching tags for note:', error);
          return { ...note, tags: [] };
        }
      })
    );

    // Format notes results with relevance scoring
    notesResults = notesWithTags.map(note => {
      const cleanContent = stripHtml(note.content);
      const noteData: any = {
        id: `note-${note.id}`,
        type: "note" as const,
        title: note.title || "Untitled Note",
        content: cleanContent,
        noteId: note.id,
        threadId: note.threadId,
        spaceId: note.spaceId,
        noteType: note.noteType || 'default',
        lastUpdated: note.updatedAt || note.createdAt,
        updatedAt: note.updatedAt || note.createdAt,
        tags: note.tags
      };
      
      // Calculate relevance score
      noteData.relevanceScore = calculateRelevanceScore(noteData, query.trim());
      
      // Truncate content for display
      noteData.content = cleanContent.substring(0, 150) + (cleanContent.length > 150 ? "..." : "");
      
      return noteData;
    });

    // Get note counts for threads
    const threadNoteCounts = await Promise.all(
      threads.map(async (thread) => {
        const noteCount = await db
          .select({ count: count() })
          .from(Notes)
          .where(and(eq(Notes.userId, userId), eq(Notes.threadId, thread.id)));
        return { threadId: thread.id, count: noteCount[0]?.count || 0 };
      })
    );

    // Format threads results with relevance scoring
    threadsResults = threads.map(thread => {
      const noteCountData = threadNoteCounts.find(tc => tc.threadId === thread.id);
      const noteCount = noteCountData?.count || 0;
      const threadData: any = {
        id: `thread-${thread.id}`,
        type: "thread" as const,
        title: thread.title,
        subtitle: `${noteCount} notes`,
        count: noteCount,
        threadId: thread.id,
        spaceId: thread.spaceId,
        lastUpdated: formatRelativeTime(thread.updatedAt || thread.createdAt),
        updatedAt: thread.updatedAt || thread.createdAt,
        accentColor: getThreadColorCSS(thread.color),
      };
      
      // Calculate relevance score for threads
      threadData.relevanceScore = calculateRelevanceScore(threadData, query.trim());
      
      return threadData;
    });

    // Combine all results and sort by relevance score first, then by date
    searchResults = [...notesResults, ...threadsResults].sort((a, b) => {
      // First sort by relevance score (higher is better)
      if (a.relevanceScore !== b.relevanceScore) {
        return b.relevanceScore - a.relevanceScore;
      }
      // Then by date (newer is better)
      return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime();
    });

  } catch (error) {
    console.error("Error performing search:", error);
    searchResults = [];
    notesResults = [];
    threadsResults = [];
  }
}

// Note: Tab filtering is now handled by the TabNav component with data-tab-content attributes
---

<Layout title="Find - Harvous" contentType="dashboard" currentThread={null} currentSpace={null}>
  <!-- Navigation Column -->
  <NavigationColumnReact 
    slot="navigation"
    inboxCount={0}
    spaces={[]}
    activeThread={null}
    currentSpace={null}
    isNote={false}
    currentId={undefined}
    showProfile={false}
    initials={initials}
    userColor={userColor}
  />

  <!-- Main Column -->
  <div slot="main" class="h-full">
    <div class="flex flex-col h-full">
      <CardStack title="Find" headerBgColor="var(--color-paper)">
        <div class="flex flex-col gap-6">
          <!-- Search Input -->
          <div class="w-full" x-data="{ 
              searchQuery: ''
            }" x-init="
              const updateSearchQuery = () => {
                const urlParams = new URLSearchParams(window.location.search);
                searchQuery = urlParams.get('q') || '';
              };
              updateSearchQuery();
              
              // Listen for URL changes (for View Transitions)
              window.addEventListener('popstate', updateSearchQuery);
              document.addEventListener('astro:page-load', updateSearchQuery);
            ">
            <form method="GET" action="/find" class="w-full relative" x-on:submit="
              if (!searchQuery.trim()) { 
                $event.preventDefault(); 
              } else {
                // Save to recent searches - count will be updated after search results load
                const recentSearches = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
                const searchTerm = searchQuery.trim();
                const newSearchItem = { term: searchTerm, count: 0 };
                const filteredSearches = recentSearches.filter(s => s.term !== searchTerm);
                const newSearches = [newSearchItem, ...filteredSearches];
                localStorage.setItem('harvous-recent-searches', JSON.stringify(newSearches.slice(0, 10)));
              }
            ">
              <div class="w-full search-input rounded-3xl grid items-center grid-cols-[auto_1fr_auto] py-5 px-4 gap-3 min-h-[64px]">
                <svg width="20" height="20" class="fill-[var(--color-pebble-grey)]" viewBox="0 0 512 512">
                  <path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/>
                </svg>
                <input 
                  type="text" 
                  name="q"
                  x-model="searchQuery"
                  role="searchbox"
                  aria-label="Find"
                  class="outline-none bg-transparent text-subtitle text-[var(--color-deep-grey)] placeholder:text-[var(--color-pebble-grey)]" 
                  placeholder="Find notes and threads..."
                />
                <svg 
                  x-show="Boolean(searchQuery)" 
                  x-cloak
                  x-on:click="searchQuery = ''; window.location.href = '/find';"
                  role="button"
                  aria-label="Clear find"
                  width="20" 
                  height="20"
                  class="fill-[var(--color-deep-grey)] cursor-pointer" 
                  viewBox="0 0 384 512"
                >
                  <path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/>
                </svg>
              </div>
              
            </form>
          </div>

          <!-- Tab Navigation -->
          {query && (
            <div class="flex flex-col gap-3">
              <TabNav 
                tabs={[
                  { 
                    id: "all", 
                    label: "All", 
                    isActive: activeTab === 'all' 
                  },
                  { 
                    id: "notes", 
                    label: "Notes", 
                    isActive: activeTab === 'notes' 
                  },
                  { 
                    id: "threads", 
                    label: "Threads", 
                    isActive: activeTab === 'threads' 
                  }
                ]}
                class="search-tabs"
              />
              
              <!-- All Content -->
              <div class="search-results flex flex-col" data-tab-content="all">
                {searchResults.length > 0 ? (
                  searchResults.map(item => (
                    <div class={`content-item ${item.type}-item mb-3`}>
                      <a 
                        href={item.type === 'thread' ? `/${item.threadId}` : `/${item.noteId}`}
                        class="block transition-transform duration-200 hover:scale-[1.002]"
                      >
                        {item.type === 'note' ? (
                          <CardNote 
                            title={item.title}
                            content={item.content}
                            noteType={item.noteType || 'default'}
                          />
                        ) : (
                          <CardThread 
                            title={item.title}
                            subtitle={item.subtitle}
                            count={item.count}
                            accentColor={item.accentColor}
                            lastUpdated={item.lastUpdated}
                          />
                        )}
                      </a>
                    </div>
                  ))
                ) : (
                  <div class="flex flex-col items-center justify-center min-h-[300px] w-full text-center">
                    <div class="flex flex-col gap-2 items-center justify-center">
                      <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                        <p>No results found</p>
                      </div>
                      <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                        <p>Try searching for different keywords or check your spelling.</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              <!-- Notes Only Content -->
              <div class="search-results flex flex-col hidden" data-tab-content="notes">
                {notesResults.length > 0 ? (
                  notesResults.map(item => (
                    <div class={`content-item ${item.type}-item mb-3`}>
                      <a 
                        href={`/${item.noteId}`}
                        class="block transition-transform duration-200 hover:scale-[1.002]"
                      >
                        <CardNote 
                          title={item.title}
                          content={item.content}
                          noteType={item.noteType || 'default'}
                        />
                      </a>
                    </div>
                  ))
                ) : (
                  <div class="flex flex-col items-center justify-center min-h-[300px] w-full text-center">
                    <div class="flex flex-col gap-2 items-center justify-center">
                      <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                        <p>No notes found</p>
                      </div>
                      <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                        <p>Try searching for different keywords or check your spelling.</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
              
              <!-- Threads Only Content -->
              <div class="search-results flex flex-col hidden" data-tab-content="threads">
                {threadsResults.length > 0 ? (
                  threadsResults.map(item => (
                    <div class={`content-item ${item.type}-item mb-3`}>
                      <a 
                        href={`/${item.threadId}`}
                        class="block transition-transform duration-200 hover:scale-[1.002]"
                      >
                        <CardThread 
                          title={item.title}
                          subtitle={item.subtitle}
                          count={item.count}
                          accentColor={item.accentColor}
                          lastUpdated={item.lastUpdated}
                        />
                      </a>
                    </div>
                  ))
                ) : (
                  <div class="flex flex-col items-center justify-center min-h-[300px] w-full text-center">
                    <div class="flex flex-col gap-2 items-center justify-center">
                      <div class="font-sans font-semibold text-[#4a473d] text-[24px] leading-[1.2]">
                        <p>No threads found</p>
                      </div>
                      <div class="font-sans font-normal text-[#78766f] text-[16px] leading-[1.3] max-w-[250px]">
                        <p>Try searching for different keywords or check your spelling.</p>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}

          <!-- Empty State (no search query) -->
          {!query && (
            <div class="flex flex-col gap-6">

              <!-- Recent Searches -->
              <RecentSearches client:load="react" />
            </div>
          )}
        </div>
      </CardStack>
    </div>
  </div>

  <!-- Mobile Navigation -->
  <div slot="mobile-navigation">
    <MobileNavigation 
      spaces={[]}
      threads={[]}
      inboxCount={0}
      currentSpace={null}
      currentThread={null}
      initials={initials}
      userColor={userColor}
    />
  </div>

  <!-- Mobile Additional -->
  <div slot="mobile-additional">
    <MobileAdditional contentType="dashboard" currentSpace={null} />
  </div>
</Layout>

<style>
  .search-input {
    background: var(--color-gradient-gray);
    box-shadow: var(--shadow-small);
  }
  
  .space-button {
    will-change: transform;
    transition: box-shadow 0.125s ease-in-out;
  }

  .space-button:active {
    filter: brightness(0.97);
    box-shadow: 
      0px -1px 0px 0px rgba(120, 118, 111, 0.2) inset,
      0px 1px 0px 0px rgba(120, 118, 111, 0.2) inset;
  }

  .space-button:active > div {
    translate: 0 0;
    transform: scale(0.98);
  }

  /* Close icon hover states handled by RecentSearches React component */
</style>

<script>
  // Handle tab navigation with URL updates
  document.addEventListener('DOMContentLoaded', () => {
    const tabButtons = document.querySelectorAll('.search-tabs [data-tab-button]');
    
    tabButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        e.preventDefault();
        const tabId = button.getAttribute('data-tab-id');
        if (tabId) {
          const url = new URL(window.location.href);
          url.searchParams.set('tab', tabId);
          window.location.href = url.toString();
        }
      });
    });
  });

  // Recent searches functionality is now handled by RecentSearches React component
  // Keep removeFromRecentSearches globally available for updateCurrentSearchCount compatibility
  function removeFromRecentSearches(searchTerm: string) {
    const recentSearches = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
    const updatedSearches = recentSearches.filter((search: any) => {
      // Handle both old format (strings) and new format (objects)
      const term = typeof search === 'string' ? search : search.term;
      return term !== searchTerm;
    });
    localStorage.setItem('harvous-recent-searches', JSON.stringify(updatedSearches));
    
    // Trigger reactivity by dispatching a custom event
    window.dispatchEvent(new CustomEvent('recent-searches-updated'));
  }

  // Make function globally available for compatibility
  (window as any).removeFromRecentSearches = removeFromRecentSearches;

  // Update result count for current search
  function updateCurrentSearchCount() {
    const urlParams = new URLSearchParams(window.location.search);
    const currentQuery = urlParams.get('q');
    
    if (currentQuery) {
      // Only count visible results from the "All" tab (which is the default active tab)
      const allTabResults = document.querySelector('[data-tab-content="all"]');
      let resultCount = 0;
      
      if (allTabResults) {
        // Count all content items in the "All" tab (it's the default visible tab)
        const visibleResults = allTabResults.querySelectorAll('.content-item');
        resultCount = visibleResults.length;
      } else {
        // Fallback: count all visible content items
        const allVisibleResults = document.querySelectorAll('.content-item');
        resultCount = allVisibleResults.length;
      }
      
      const recentSearches = JSON.parse(localStorage.getItem('harvous-recent-searches') || '[]');
      const updatedSearches = recentSearches.map((search: any) => {
        if (search.term === currentQuery) {
          return { ...search, count: resultCount };
        }
        return search;
      });
      localStorage.setItem('harvous-recent-searches', JSON.stringify(updatedSearches));
      
      // Trigger Alpine.js reactivity
      window.dispatchEvent(new CustomEvent('recent-searches-updated'));
    }
  }

  // Run after page loads and also after View Transitions
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateCurrentSearchCount, 200); // Increased delay
    
    // Also use MutationObserver to watch for search results
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'childList' && (mutation.target as Element).classList?.contains('search-results')) {
          setTimeout(updateCurrentSearchCount, 100);
        }
      });
    });
    
    // Observe the search results container
    const searchResultsContainer = document.querySelector('.search-results');
    if (searchResultsContainer) {
      observer.observe(searchResultsContainer, { childList: true, subtree: true });
    }
  });
  
  // Also run after View Transitions
  document.addEventListener('astro:page-load', () => {
    setTimeout(updateCurrentSearchCount, 200);
  });
</script>

