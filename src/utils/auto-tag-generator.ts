import { findKeywordsInText, BIBLE_STUDY_KEYWORDS } from './bible-study-keywords';
import { db, Tags, NoteTags, eq, and } from 'astro:db';

export interface AutoTagSuggestion {
  keyword: string;
  category: string;
  confidence: number;
  isExisting: boolean;
  tagId?: string;
}

export interface AutoTagResult {
  suggestions: AutoTagSuggestion[];
  totalFound: number;
  highConfidence: number;
}

/**
 * Generate auto-tag suggestions for a note based on its content
 */
export async function generateAutoTags(
  noteTitle: string, 
  noteContent: string, 
  userId: string
): Promise<AutoTagResult> {
  try {

    // Combine title and content for analysis
    const fullText = `${noteTitle || ''} ${noteContent || ''}`.trim();
    
    if (!fullText) {
      return { suggestions: [], totalFound: 0, highConfidence: 0 };
    }

    // Find keywords in the text
    const foundKeywords = findKeywordsInText(fullText);
    
    // Get existing tags for the user to avoid duplicates
    const existingTags = await db
      .select()
      .from(Tags)
      .where(eq(Tags.userId, userId));

    const existingTagNames = new Set(existingTags.map(tag => tag.name.toLowerCase()));

    // Process suggestions
    const suggestions: AutoTagSuggestion[] = [];
    let highConfidence = 0;

    for (const { keyword, confidence } of foundKeywords) {
      // Only suggest if confidence is above threshold
      if (confidence >= 0.6) {
        const isExisting = existingTagNames.has(keyword.name.toLowerCase());
        
        suggestions.push({
          keyword: keyword.name,
          category: keyword.category,
          confidence: confidence,
          isExisting: isExisting,
          tagId: isExisting ? existingTags.find(t => t.name.toLowerCase() === keyword.name.toLowerCase())?.id : undefined
        });

        if (confidence >= 0.8) {
          highConfidence++;
        }
      }
    }

    // Sort by confidence (highest first)
    suggestions.sort((a, b) => b.confidence - a.confidence);

    // Limit to top 10 suggestions
    const topSuggestions = suggestions.slice(0, 10);

    return {
      suggestions: topSuggestions,
      totalFound: suggestions.length,
      highConfidence: highConfidence
    };

  } catch (error) {
    console.error('Error generating auto tags:', error);
    return { suggestions: [], totalFound: 0, highConfidence: 0 };
  }
}

/**
 * Apply auto-generated tags to a note
 */
export async function applyAutoTags(
  noteId: string,
  suggestions: AutoTagSuggestion[],
  userId: string
): Promise<{ applied: number; errors: string[] }> {

  const errors: string[] = [];
  let applied = 0;

  for (const suggestion of suggestions) {
    try {
      let tagId = suggestion.tagId;

      // Create tag if it doesn't exist
      if (!tagId) {
        const newTagId = `tag_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        await db.insert(Tags).values({
          id: newTagId,
          name: suggestion.keyword,
          color: getColorForCategory(suggestion.category),
          category: suggestion.category,
          userId: userId,
          isSystem: true, // Auto-generated tags are system tags
          createdAt: new Date(),
        });

        tagId = newTagId;
      }

      // Create note-tag relationship
      const relationId = `note_tag_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      await db.insert(NoteTags).values({
        id: relationId,
        noteId: noteId,
        tagId: tagId,
        isAutoGenerated: true,
        confidence: suggestion.confidence,
        createdAt: new Date(),
      });

      applied++;

    } catch (error) {
      console.error(`Error applying tag ${suggestion.keyword}:`, error);
      errors.push(`Failed to apply tag "${suggestion.keyword}": ${error}`);
    }
  }

  return { applied, errors };
}

/**
 * Get color for tag category
 */
function getColorForCategory(category: string): string {
  const colorMap: Record<string, string> = {
    'spiritual': '#006eff',
    'biblical': '#28a745',
    'character': '#ffc107',
    'place': '#17a2b8',
    'book': '#6f42c1',
    'theme': '#fd7e14',
    'life': '#e83e8c'
  };

  return colorMap[category] || '#006eff';
}

/**
 * Remove auto-generated tags from a note
 */
export async function removeAutoTags(noteId: string): Promise<number> {

  try {
    const result = await db
      .delete(NoteTags)
      .where(and(
        eq(NoteTags.noteId, noteId),
        eq(NoteTags.isAutoGenerated, true)
      ));

    return 1; // Success
  } catch (error) {
    console.error('Error removing auto tags:', error);
    return 0;
  }
}

/**
 * Regenerate auto tags for a note (remove old ones and create new ones)
 */
export async function regenerateAutoTags(
  noteId: string,
  noteTitle: string,
  noteContent: string,
  userId: string
): Promise<{ applied: number; errors: string[] }> {
  try {
    // Remove existing auto-generated tags
    await removeAutoTags(noteId);

    // Generate new suggestions
    const result = await generateAutoTags(noteTitle, noteContent, userId);

    // Apply new tags
    const applied = await applyAutoTags(noteId, result.suggestions, userId);

    return applied;
  } catch (error) {
    console.error('Error regenerating auto tags:', error);
    return { applied: 0, errors: [`Failed to regenerate tags: ${error}`] };
  }
}
