#!/usr/bin/env node

/**
 * Test script for delete account functionality
 * This script creates test data, then tests that all user data is deleted
 * from both the database and Clerk
 */

import { db, Notes, Threads, Spaces, Tags, NoteTags, NoteThreads, UserMetadata, UserXP, Comments, ScriptureMetadata, NoteThreadAccess, Members, eq } from 'astro:db';
import { randomUUID } from 'crypto';

// Test user ID - use a unique ID for testing
const TEST_USER_ID = `test_delete_${Date.now()}`;

// Helper function to count records
async function countRecords(table, userId) {
  try {
    const records = await db.select().from(table).where(eq(table.userId || table.noteId ? table : null, userId)).all();
    return records.length;
  } catch (error) {
    // Some tables might not have userId column, try alternate approach
    if (table === NoteTags || table === NoteThreads || table === NoteThreadAccess || table === Comments || table === ScriptureMetadata) {
      // These tables need noteId, so we'll check differently
      return 0; // Will be checked separately
    }
    return 0;
  }
}

// Helper to count records by noteId
async function countByNoteId(table, noteIds) {
  if (noteIds.length === 0) return 0;
  let count = 0;
  for (const noteId of noteIds) {
    try {
      const records = await db.select().from(table).where(eq(table.noteId, noteId)).all();
      count += records.length;
    } catch (error) {
      // Skip if error
    }
  }
  return count;
}

async function createTestData() {
  console.log('üìù Creating test data for user:', TEST_USER_ID);
  
  const testData = {
    spaceId: null,
    threadId: null,
    noteIds: [],
    tagIds: [],
  };

  // Create a space
  const spaceId = randomUUID();
  await db.insert(Spaces).values({
    id: spaceId,
    title: 'Test Space',
    userId: TEST_USER_ID,
    createdAt: new Date(),
    isActive: true,
    isPublic: false,
    order: 0,
  });
  testData.spaceId = spaceId;
  console.log('  ‚úì Created space:', spaceId);

  // Create a thread
  const threadId = randomUUID();
  await db.insert(Threads).values({
    id: threadId,
    title: 'Test Thread',
    userId: TEST_USER_ID,
    spaceId: spaceId,
    createdAt: new Date(),
    isPublic: false,
    isPinned: false,
    order: 0,
  });
  testData.threadId = threadId;
  console.log('  ‚úì Created thread:', threadId);

  // Create notes
  for (let i = 0; i < 3; i++) {
    const noteId = randomUUID();
    await db.insert(Notes).values({
      id: noteId,
      title: `Test Note ${i + 1}`,
      content: `<p>Test content ${i + 1}</p>`,
      threadId: threadId,
      spaceId: spaceId,
      userId: TEST_USER_ID,
      simpleNoteId: i + 1,
      createdAt: new Date(),
      isPublic: false,
      isFeatured: false,
      order: 0,
    });
    testData.noteIds.push(noteId);
    console.log(`  ‚úì Created note ${i + 1}:`, noteId);
  }

  // Create a scripture note
  const scriptureNoteId = randomUUID();
  await db.insert(Notes).values({
    id: scriptureNoteId,
    title: 'John 3:16',
    content: '<p>For God so loved the world...</p>',
    threadId: threadId,
    userId: TEST_USER_ID,
    noteType: 'scripture',
    createdAt: new Date(),
    isPublic: false,
    isFeatured: false,
    order: 0,
  });
  testData.noteIds.push(scriptureNoteId);
  console.log('  ‚úì Created scripture note:', scriptureNoteId);

  // Create tags
  for (let i = 0; i < 2; i++) {
    const tagId = randomUUID();
    await db.insert(Tags).values({
      id: tagId,
      name: `Test Tag ${i + 1}`,
      userId: TEST_USER_ID,
      isSystem: false,
      createdAt: new Date(),
    });
    testData.tagIds.push(tagId);
    console.log(`  ‚úì Created tag ${i + 1}:`, tagId);
  }

  // Create NoteTags relationships
  for (let i = 0; i < testData.noteIds.length; i++) {
    const noteId = testData.noteIds[i];
    const tagId = testData.tagIds[i % testData.tagIds.length];
    await db.insert(NoteTags).values({
      id: randomUUID(),
      noteId: noteId,
      tagId: tagId,
      isAutoGenerated: false,
      createdAt: new Date(),
    });
    console.log(`  ‚úì Created NoteTag relationship for note ${i + 1}`);
  }

  // Create NoteThreads relationships
  for (const noteId of testData.noteIds) {
    await db.insert(NoteThreads).values({
      id: randomUUID(),
      noteId: noteId,
      threadId: testData.threadId,
      createdAt: new Date(),
    });
    console.log('  ‚úì Created NoteThread relationship');
  }

  // Create Comments
  for (const noteId of testData.noteIds.slice(0, 2)) {
    await db.insert(Comments).values({
      id: randomUUID(),
      noteId: noteId,
      userId: TEST_USER_ID,
      content: 'Test comment',
      createdAt: new Date(),
    });
    console.log('  ‚úì Created comment');
  }

  // Create ScriptureMetadata
  await db.insert(ScriptureMetadata).values({
    id: randomUUID(),
    noteId: scriptureNoteId,
    reference: 'John 3:16',
    book: 'John',
    chapter: 3,
    verse: 16,
    translation: 'NET',
    originalText: 'For God so loved the world...',
    createdAt: new Date(),
  });
  console.log('  ‚úì Created ScriptureMetadata');

  // Create NoteThreadAccess
  for (const noteId of testData.noteIds) {
    await db.insert(NoteThreadAccess).values({
      id: randomUUID(),
      userId: TEST_USER_ID,
      noteId: noteId,
      threadId: testData.threadId,
      lastAccessed: new Date(),
      accessCount: 1,
    });
    console.log('  ‚úì Created NoteThreadAccess');
  }

  // Create Members (for the space)
  await db.insert(Members).values({
    id: randomUUID(),
    userId: TEST_USER_ID,
    spaceId: spaceId,
    role: 'owner',
    createdAt: new Date(),
  });
  console.log('  ‚úì Created Member');

  // Create UserMetadata
  await db.insert(UserMetadata).values({
    id: `user_metadata_${TEST_USER_ID}`,
    userId: TEST_USER_ID,
    highestSimpleNoteId: 4,
    userColor: 'paper',
    createdAt: new Date(),
  });
  console.log('  ‚úì Created UserMetadata');

  // Create UserXP
  for (let i = 0; i < 3; i++) {
    await db.insert(UserXP).values({
      id: randomUUID(),
      userId: TEST_USER_ID,
      activityType: 'note_created',
      xpAmount: 10,
      relatedId: testData.noteIds[i],
      createdAt: new Date(),
    });
    console.log(`  ‚úì Created UserXP ${i + 1}`);
  }

  return testData;
}

async function verifyTestData() {
  console.log('\nüîç Verifying test data exists...');
  
  const notes = await db.select().from(Notes).where(eq(Notes.userId, TEST_USER_ID)).all();
  const threads = await db.select().from(Threads).where(eq(Threads.userId, TEST_USER_ID)).all();
  const spaces = await db.select().from(Spaces).where(eq(Spaces.userId, TEST_USER_ID)).all();
  const tags = await db.select().from(Tags).where(eq(Tags.userId, TEST_USER_ID)).all();
  const userMetadata = await db.select().from(UserMetadata).where(eq(UserMetadata.userId, TEST_USER_ID)).all();
  const userXP = await db.select().from(UserXP).where(eq(UserXP.userId, TEST_USER_ID)).all();

  const noteIds = notes.map(n => n.id);
  const spaceIds = spaces.map(s => s.id);

  // Count junction table records
  let noteTagsCount = 0;
  let noteThreadsCount = 0;
  let commentsCount = 0;
  let scriptureMetadataCount = 0;
  let noteThreadAccessCount = 0;
  let membersCount = 0;

  for (const noteId of noteIds) {
    const nts = await db.select().from(NoteTags).where(eq(NoteTags.noteId, noteId)).all();
    noteTagsCount += nts.length;
    
    const ntrs = await db.select().from(NoteThreads).where(eq(NoteThreads.noteId, noteId)).all();
    noteThreadsCount += ntrs.length;
    
    const cmts = await db.select().from(Comments).where(eq(Comments.noteId, noteId)).all();
    commentsCount += cmts.length;
    
    try {
      const sm = await db.select().from(ScriptureMetadata).where(eq(ScriptureMetadata.noteId, noteId)).all();
      scriptureMetadataCount += sm.length;
    } catch (e) {
      // Skip if error
    }
    
    const nta = await db.select().from(NoteThreadAccess).where(eq(NoteThreadAccess.noteId, noteId)).all();
    noteThreadAccessCount += nta.length;
  }

  for (const spaceId of spaceIds) {
    const mems = await db.select().from(Members).where(eq(Members.spaceId, spaceId)).all();
    membersCount += mems.length;
  }

  const counts = {
    notes: notes.length,
    threads: threads.length,
    spaces: spaces.length,
    tags: tags.length,
    noteTags: noteTagsCount,
    noteThreads: noteThreadsCount,
    comments: commentsCount,
    scriptureMetadata: scriptureMetadataCount,
    noteThreadAccess: noteThreadAccessCount,
    members: membersCount,
    userMetadata: userMetadata.length,
    userXP: userXP.length,
  };

  console.log('  Test data counts:');
  Object.entries(counts).forEach(([table, count]) => {
    console.log(`    ${table}: ${count}`);
  });

  return { counts, noteIds, spaceIds };
}

async function runDeleteAccount() {
  console.log('\nüóëÔ∏è  Running delete account logic...');
  
  const userId = TEST_USER_ID;

  // 1. Fetch note IDs first (needed for junction table deletions)
  const userNotes = await db.select({ id: Notes.id }).from(Notes).where(eq(Notes.userId, userId)).all();
  const noteIds = userNotes.map(n => n.id);
  
  console.log(`  Found ${noteIds.length} notes to delete`);
  
  // Delete junction tables and related data
  if (noteIds.length > 0) {
    // Delete NoteThreads relationships
    for (const noteId of noteIds) {
      await db.delete(NoteThreads).where(eq(NoteThreads.noteId, noteId));
    }
    console.log('  ‚úì Deleted NoteThreads');
    
    // Delete NoteTags relationships
    for (const noteId of noteIds) {
      await db.delete(NoteTags).where(eq(NoteTags.noteId, noteId));
    }
    console.log('  ‚úì Deleted NoteTags');
    
    // Delete Comments
    for (const noteId of noteIds) {
      await db.delete(Comments).where(eq(Comments.noteId, noteId));
    }
    console.log('  ‚úì Deleted Comments');
    
    // Delete ScriptureMetadata
    for (const noteId of noteIds) {
      await db.delete(ScriptureMetadata).where(eq(ScriptureMetadata.noteId, noteId));
    }
    console.log('  ‚úì Deleted ScriptureMetadata');
    
    // Delete NoteThreadAccess
    for (const noteId of noteIds) {
      await db.delete(NoteThreadAccess).where(eq(NoteThreadAccess.noteId, noteId));
    }
    console.log('  ‚úì Deleted NoteThreadAccess');
  }

  // 2. Delete Notes
  await db.delete(Notes).where(eq(Notes.userId, userId));
  console.log('  ‚úì Deleted Notes');

  // 3. Delete Threads
  await db.delete(Threads).where(eq(Threads.userId, userId));
  console.log('  ‚úì Deleted Threads');

  // 4. Delete Spaces and Members
  const userSpaces = await db.select({ id: Spaces.id }).from(Spaces).where(eq(Spaces.userId, userId)).all();
  const spaceIds = userSpaces.map(s => s.id);
  
  if (spaceIds.length > 0) {
    for (const spaceId of spaceIds) {
      await db.delete(Members).where(eq(Members.spaceId, spaceId));
    }
    console.log('  ‚úì Deleted Members');
  }
  
  await db.delete(Spaces).where(eq(Spaces.userId, userId));
  console.log('  ‚úì Deleted Spaces');

  // 5. Delete Tags (user's tags)
  await db.delete(Tags).where(eq(Tags.userId, userId));
  console.log('  ‚úì Deleted Tags');

  // 6. Delete UserXP
  await db.delete(UserXP).where(eq(UserXP.userId, userId));
  console.log('  ‚úì Deleted UserXP');

  // 7. Delete UserMetadata
  await db.delete(UserMetadata).where(eq(UserMetadata.userId, userId));
  console.log('  ‚úì Deleted UserMetadata');
}

async function verifyDeletion() {
  console.log('\n‚úÖ Verifying all data is deleted...');
  
  const notes = await db.select().from(Notes).where(eq(Notes.userId, TEST_USER_ID)).all();
  const threads = await db.select().from(Threads).where(eq(Threads.userId, TEST_USER_ID)).all();
  const spaces = await db.select().from(Spaces).where(eq(Spaces.userId, TEST_USER_ID)).all();
  const tags = await db.select().from(Tags).where(eq(Tags.userId, TEST_USER_ID)).all();
  const userMetadata = await db.select().from(UserMetadata).where(eq(UserMetadata.userId, TEST_USER_ID)).all();
  const userXP = await db.select().from(UserXP).where(eq(UserXP.userId, TEST_USER_ID)).all();

  const noteIds = notes.map(n => n.id);
  const spaceIds = spaces.map(s => s.id);

  // Count junction table records
  let noteTagsCount = 0;
  let noteThreadsCount = 0;
  let commentsCount = 0;
  let scriptureMetadataCount = 0;
  let noteThreadAccessCount = 0;
  let membersCount = 0;

  for (const noteId of noteIds) {
    const nts = await db.select().from(NoteTags).where(eq(NoteTags.noteId, noteId)).all();
    noteTagsCount += nts.length;
    
    const ntrs = await db.select().from(NoteThreads).where(eq(NoteThreads.noteId, noteId)).all();
    noteThreadsCount += ntrs.length;
    
    const cmts = await db.select().from(Comments).where(eq(Comments.noteId, noteId)).all();
    commentsCount += cmts.length;
    
    try {
      const sm = await db.select().from(ScriptureMetadata).where(eq(ScriptureMetadata.noteId, noteId)).all();
      scriptureMetadataCount += sm.length;
    } catch (e) {
      // Skip if error
    }
    
    const nta = await db.select().from(NoteThreadAccess).where(eq(NoteThreadAccess.noteId, noteId)).all();
    noteThreadAccessCount += nta.length;
  }

  for (const spaceId of spaceIds) {
    const mems = await db.select().from(Members).where(eq(Members.spaceId, spaceId)).all();
    membersCount += mems.length;
  }

  const counts = {
    notes: notes.length,
    threads: threads.length,
    spaces: spaces.length,
    tags: tags.length,
    noteTags: noteTagsCount,
    noteThreads: noteThreadsCount,
    comments: commentsCount,
    scriptureMetadata: scriptureMetadataCount,
    noteThreadAccess: noteThreadAccessCount,
    members: membersCount,
    userMetadata: userMetadata.length,
    userXP: userXP.length,
  };

  console.log('  Remaining data counts:');
  const allZero = Object.entries(counts).every(([table, count]) => {
    const isZero = count === 0;
    console.log(`    ${table}: ${count} ${isZero ? '‚úì' : '‚ùå FAILED'}`);
    return isZero;
  });

  if (allZero) {
    console.log('\n‚úÖ All database records deleted successfully!');
  } else {
    console.log('\n‚ùå Some records were not deleted!');
    process.exit(1);
  }

  return allZero;
}

async function testClerkDeletion() {
  console.log('\nüîê Testing Clerk deletion...');
  
  const clerkSecretKey = process.env.CLERK_SECRET_KEY;
  
  if (!clerkSecretKey) {
    console.log('  ‚ö†Ô∏è  CLERK_SECRET_KEY not found in environment');
    console.log('  ‚ö†Ô∏è  Skipping Clerk deletion test');
    console.log('  ‚ö†Ô∏è  Note: This is expected in test environments');
    return;
  }

  // Note: We can't actually delete a real Clerk user in a test
  // This just verifies the API call would work
  console.log('  ‚ÑπÔ∏è  Clerk deletion requires a real user ID');
  console.log('  ‚ÑπÔ∏è  To test Clerk deletion, use the delete account feature in the UI');
  console.log('  ‚ÑπÔ∏è  with a real authenticated user');
}

async function runTest() {
  console.log('üß™ Testing Delete Account Functionality\n');
  console.log('='.repeat(60));
  
  try {
    // Step 1: Create test data
    await createTestData();
    
    // Step 2: Verify test data exists
    const { counts: beforeCounts } = await verifyTestData();
    
    // Step 3: Run delete account
    await runDeleteAccount();
    
    // Step 4: Verify deletion
    const allDeleted = await verifyDeletion();
    
    // Step 5: Test Clerk deletion (informational)
    await testClerkDeletion();
    
    console.log('\n' + '='.repeat(60));
    if (allDeleted) {
      console.log('\n‚úÖ TEST PASSED: All user data successfully deleted from database');
      console.log('\nüìù Note: Clerk deletion should be tested manually with a real user');
      console.log('   in the UI, as it requires Clerk authentication.');
    } else {
      console.log('\n‚ùå TEST FAILED: Some data was not deleted');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('\n‚ùå Test error:', error);
    console.error(error.stack);
    process.exit(1);
  }
}

// Run the test
runTest();

